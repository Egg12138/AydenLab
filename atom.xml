<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://https://github.com/Egg12138</id>
    <title>Gridea</title>
    <updated>2021-02-06T15:35:13.391Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://https://github.com/Egg12138"/>
    <link rel="self" href="https://https://github.com/Egg12138/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://https://github.com/Egg12138/images/avatar.png</logo>
    <icon>https://https://github.com/Egg12138/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[一些英语注释用的词，组，句]]></title>
        <id>https://https://github.com/Egg12138/post/yi-xie-ying-yu-zhu-shi-yong-de-ci-zu-ju/</id>
        <link href="https://https://github.com/Egg12138/post/yi-xie-ying-yu-zhu-shi-yong-de-ci-zu-ju/">
        </link>
        <updated>2021-02-06T14:39:54.000Z</updated>
        <content type="html"><![CDATA[<p>do these statements，执行这些语句<br>
through the loop once执行一次这个循环，  语句千万不要随便用Sentence！<br>
evaluate X,对X求值<br>
increment只是递增<br>
return to the beginning of the loop,一般略去定冠词:return to beginning of loop</p>
<p>被允许的可用C is not object to ...</p>
<p>见过语法，情况或者其他，最好用encounter</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语法基础|]]></title>
        <id>https://https://github.com/Egg12138/post/c-yu-fa-ji-chu-orbian-liang/</id>
        <link href="https://https://github.com/Egg12138/post/c-yu-fa-ji-chu-orbian-liang/">
        </link>
        <updated>2021-02-05T16:15:33.000Z</updated>
        <summary type="html"><![CDATA[<p>data object</p>
<p>lvalue, a label, some are modifiable, some are not.<br>
modifiable left-value = object locator value. C11suggested.<br>
rvalue, a real obj in the memories</p>
<p>C标准const限定：</p>
<blockquote>
<pre><code>         关键字const对变量的类型加以限定，使它的值不能被改变。
          const对象一旦创建后其值就不能再改变，所以const对象必须初始化，如下：
  const int i = get_size();  //正确，在运行时初始化
  const int j = 42;  //正确，在编译时初始化
  const int k;  //不正确，k是一个未经初始化的常量
</code></pre>
</blockquote>
<p>运算，操作的对象oper-and,operand称为项，<br>
可以多重赋值:<br>
int j, t, c;<br>
c=t=j=68;  OK,赋值顺序是68--&gt;j,t,c右至左<br>
left-value = operate(l-value0,l-value1,...,l-valueN) ,operate(...)整体依然是个r-value;</p>
<h4 id="对齐宽度">对齐宽度</h4>
<p>abc<br>
1 对齐到C，宽度应该市%3而不是%2</p>
<h4 id="截断truncation">截断truncation</h4>
<pre><code>int:5/4 =&gt; 1; 6/3 = &gt; 2, 7/4 =&gt; 1;
float: 7./4 值上= 7./4. =&gt; 1.75(%.2f)
%d \n&quot;,7./4.);报错
%d\n&quot;,7./4);则不报错
</code></pre>
<h4 id="灵活之处">灵活之处</h4>
<p>相比python，C语法更灵活，感觉很棒~</p>
<ul>
<li>递增运算符<br>
<code>while (++shoe &lt; 42)，</code><br>
<code>&lt;=&gt; while (shoe &lt; 42) {........++shoe}</code>//根据下面的，这里判断的是递增后的shoe是否&lt; 42，即鞋码41为最后一个判断。 shoe++ &lt; 42则shoe达到42码时为最后一次循环。</li>
</ul>
 <center> >       即，shoe++会让shoe在与42比较之后再+1  </center>
<pre><code>    post_incresment
    ``a_post = a++: a_post = previous a and a += 1``,可以保留旧a，有时候返回旧a挺有用的。
    ``pre_b = ++b: pre_b = new_b =b =previous b +1``
    pre_incresment;
</code></pre>
<p>decrement operator同理</p>
]]></summary>
        <content type="html"><![CDATA[<p>data object</p>
<p>lvalue, a label, some are modifiable, some are not.<br>
modifiable left-value = object locator value. C11suggested.<br>
rvalue, a real obj in the memories</p>
<p>C标准const限定：</p>
<blockquote>
<pre><code>         关键字const对变量的类型加以限定，使它的值不能被改变。
          const对象一旦创建后其值就不能再改变，所以const对象必须初始化，如下：
  const int i = get_size();  //正确，在运行时初始化
  const int j = 42;  //正确，在编译时初始化
  const int k;  //不正确，k是一个未经初始化的常量
</code></pre>
</blockquote>
<p>运算，操作的对象oper-and,operand称为项，<br>
可以多重赋值:<br>
int j, t, c;<br>
c=t=j=68;  OK,赋值顺序是68--&gt;j,t,c右至左<br>
left-value = operate(l-value0,l-value1,...,l-valueN) ,operate(...)整体依然是个r-value;</p>
<h4 id="对齐宽度">对齐宽度</h4>
<p>abc<br>
1 对齐到C，宽度应该市%3而不是%2</p>
<h4 id="截断truncation">截断truncation</h4>
<pre><code>int:5/4 =&gt; 1; 6/3 = &gt; 2, 7/4 =&gt; 1;
float: 7./4 值上= 7./4. =&gt; 1.75(%.2f)
%d \n&quot;,7./4.);报错
%d\n&quot;,7./4);则不报错
</code></pre>
<h4 id="灵活之处">灵活之处</h4>
<p>相比python，C语法更灵活，感觉很棒~</p>
<ul>
<li>递增运算符<br>
<code>while (++shoe &lt; 42)，</code><br>
<code>&lt;=&gt; while (shoe &lt; 42) {........++shoe}</code>//根据下面的，这里判断的是递增后的shoe是否&lt; 42，即鞋码41为最后一个判断。 shoe++ &lt; 42则shoe达到42码时为最后一次循环。</li>
</ul>
 <center> >       即，shoe++会让shoe在与42比较之后再+1  </center>
<pre><code>    post_incresment
    ``a_post = a++: a_post = previous a and a += 1``,可以保留旧a，有时候返回旧a挺有用的。
    ``pre_b = ++b: pre_b = new_b =b =previous b +1``
    pre_incresment;
</code></pre>
<p>decrement operator同理</p>
<!-- more -->
<p>混乱：<br>
dev-c++的TDM-GC 4.9.2下，<br>
n = 3<br>
<code>y = n++ + n++;</code><br>
<code>printf(&quot;Now,y = %d, n = %d&quot;,y,n);</code><br>
<code>y = n++ + ++n;</code><br>
<code>printf(&quot;Now,y = %d, n = %d&quot;,y,n);</code><br>
output:<br>
y = 7(3+4), n =5<br>
y=12(5+7),n=7，都是比previous n大了2，<br>
可以看到再一个地方，编译器递增完立刻使用n，然后继续下一个递增。但是再别的编译器旧不一样了。这个结果C标准没定义，<br>
<strong>要避开这种混乱，Don't be too clever!</strong></p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性表复习|inPy]]></title>
        <id>https://https://github.com/Egg12138/post/xian-xing-biao-fu-xi-or-in-py/</id>
        <link href="https://https://github.com/Egg12138/post/xian-xing-biao-fu-xi-or-in-py/">
        </link>
        <updated>2021-01-30T13:25:28.000Z</updated>
        <summary type="html"><![CDATA[<p>使用单链表（ex_13)<br>
这次没有顺序表的表演了</p>
<h3 id="线性表">线性表</h3>
<h4 id="顺序表">顺序表</h4>
<h4 id="链表linkedlist">链表LinkedList</h4>
<p>在不连续的地址之间</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用单链表（ex_13)<br>
这次没有顺序表的表演了</p>
<h3 id="线性表">线性表</h3>
<h4 id="顺序表">顺序表</h4>
<h4 id="链表linkedlist">链表LinkedList</h4>
<p>在不连续的地址之间</p>
<!-- more -->
<p>A,B,C三个nodes之间有链接<br>
Using the classical strategies:<br>
是address而不是ptr！<br>
[[Value]]&amp;[[add, like 0x34]] ---&gt;---[[Value1]]&amp;[[add1]]---&gt;---[[Value2]]&amp;[[add2]]--&gt;---[[Void]]&amp;[[ending]], Value or Element<br>
单（向）链表，由指向add的ptr就可以得到整条链</p>
<h5 id="单链表">单链表</h5>
<p>operations:<br>
* is_empty()<br>
* len()<br>
* travel()<br>
* add(item)<br>
* append(x)<br>
* insert(pos<br>
* rm(x)<br>
* find(x),   the x is the node.</p>
<pre><code>calss aNode
    elem
    Next

node1: 
    elem=10
    next--point--&gt;node2
node2:
    elem=20
    next--point--&gt;node3
</code></pre>
<h3 id="address-in-py">address in py!</h3>
<p>a,b = b, a   a  tuple!<br>
内存不变，只是a,b所指的地址变化。like ptr...<br>
但是在C中，ab的指定就是对象本身</p>
<!-- more -->
<p>手动实现list obj的功能，<br>
原理很简单了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自动化测试初步]]></title>
        <id>https://https://github.com/Egg12138/post/zi-dong-hua-ce-shi-chu-bu/</id>
        <link href="https://https://github.com/Egg12138/post/zi-dong-hua-ce-shi-chu-bu/">
        </link>
        <updated>2021-01-30T13:25:28.000Z</updated>
        <summary type="html"><![CDATA[<p>使用单链表（ex_13)</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用单链表（ex_13)</p>
<!-- more -->
<p>来完成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[脑洞|UNO变体规则]]></title>
        <id>https://https://github.com/Egg12138/post/nao-dong-oruno-bian-ti-gui-ze/</id>
        <link href="https://https://github.com/Egg12138/post/nao-dong-oruno-bian-ti-gui-ze/">
        </link>
        <updated>2021-01-29T16:08:17.000Z</updated>
        <content type="html"><![CDATA[<p>首先，以下规则均出于增加游戏趣味性和难度的目的而作出的。<br>
将会使用一些概念：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>对象</th>
<th>具体内涵</th>
</tr>
</thead>
<tbody>
<tr>
<td>叠加</td>
<td>效果或牌</td>
<td>在上家的牌（或效果）生效前，打出符合（变体）规则的牌（或效果），并将这一系列牌的目标转移到下家</td>
</tr>
<tr>
<td>连对</td>
<td>一个玩家</td>
<td>将同一张牌打出多张</td>
</tr>
<tr>
<td>交换</td>
<td>交换效果目标（目标不一定是玩家持有的手牌）</td>
<td>将符合条件的牌（手牌，等）与目标</td>
</tr>
<tr>
<td>手牌</td>
<td>牌</td>
<td>玩家手上持有的牌，默认指的是集合，如交换A,B的手牌=交换A,B的所有受众持有的牌</td>
</tr>
<tr>
<td>抽取</td>
<td>牌</td>
<td>从目标区域中获得一定数量的牌</td>
</tr>
<tr>
<td>反转</td>
<td>顺序</td>
<td>一般是玩家出牌顺序</td>
</tr>
<tr>
<td>报警</td>
<td>玩家</td>
<td>喊出UNO的动作</td>
</tr>
<tr>
<td>黑牌</td>
<td>牌</td>
<td>ACE和WILD牌，拥有最高级别自由度的两张牌，两张牌的颜色为“无颜色”</td>
</tr>
<tr>
<td>明牌</td>
<td>牌</td>
<td>牌面朝上的牌</td>
</tr>
</tbody>
</table>
<p>基础规则：</p>
<ul>
<li>Wild
<ul>
<li>如果质疑成功，上家倒摸四张。但但是变色效果始终生效。下家进入正常的行动回合。（出不了依然罚摸）</li>
<li>原则不是完全绝境【只有当没有和当前牌面颜色相同的牌时才能打出，花色同颜色不同的不算】</li>
</ul>
</li>
<li>draw TWO
<ul>
<li>下家罚摸后不能出牌</li>
</ul>
</li>
<li>基本回合不出牌时，罚摸的牌不能打出</li>
<li>solo时反转作为禁止</li>
</ul>
<p>村规</p>
<ul>
<li>黑牌不能作最后一张牌</li>
<li>solo时</li>
</ul>
<h3 id="叠加类变体">叠加类变体</h3>
<h4 id="centerncenter"><center>*n</center></h4>
<blockquote>
<p>连对规则被引入游戏时，连对规则在叠加规则发动时不生效！（当手上有多张+2时，在叠加的环节，最多仍然只能出1张+2牌。）</p>
</blockquote>
<p>同花色的功能牌，可以叠加。生效于最后一名玩家</p>
<table>
<thead>
<tr>
<th>具体牌</th>
<th>特殊效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+2n</td>
<td>略</td>
</tr>
<tr>
<td>禁</td>
<td></td>
</tr>
<tr>
<td>+4</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="量的变体">量的变体</h3>
<h4 id="更多选择xx默认为106x13">更多选择（x),x默认为10，6&lt;x&lt;13,</h4>
<p>玩家初始可以摸x张牌，可以观察后弃掉0-n张明牌，但最后的开局手牌数不得小于7<br>
注意：在洗牌之前，这些被弃的牌都要摆放好，方便部分玩家记牌</p>
<h3 id="玩家能力变体">玩家能力变体</h3>
<p>为了保留游戏的简洁性，不引入复杂的角色技能这样的玩法。<br>
而是引入几个小变体，将这些变体作为玩家的技能。选中技能的玩家才能使用该变体能力，在发动能力的时候需要说明。</p>
<p>包括：</p>
<ul>
<li>反转重铸</li>
<li>更多选择(12)</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[|UNO变体规则]]></title>
        <id>https://https://github.com/Egg12138/post/oruno-bian-ti-gui-ze/</id>
        <link href="https://https://github.com/Egg12138/post/oruno-bian-ti-gui-ze/">
        </link>
        <updated>2021-01-29T16:08:17.000Z</updated>
        <content type="html"><![CDATA[<p>首先，以下规则均出于增加游戏趣味性和难度的目的而作出的。<br>
将会使用一些概念：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>对象</th>
<th>具体内涵</th>
</tr>
</thead>
<tbody>
<tr>
<td>叠加</td>
<td>效果或牌</td>
<td>在上家的牌（或效果）生效前，打出符合（变体）规则的牌（或效果），并将这一系列牌的目标转移到下家</td>
</tr>
<tr>
<td>连对</td>
<td>牌</td>
<td>将同一张牌打出多张</td>
</tr>
<tr>
<td>交换</td>
<td>交换效果目标（目标不一定是玩家持有的手牌）</td>
<td>将符合条件的牌（手牌，等）与目标</td>
</tr>
<tr>
<td>手牌</td>
<td>牌</td>
<td>玩家手上持有的牌，默认指的是集合，如交换A,B的手牌=交换A,B的所有受众持有的牌</td>
</tr>
<tr>
<td>抽取</td>
<td>牌</td>
<td>从目标区域中获得一定数量的牌</td>
</tr>
<tr>
<td>反转</td>
<td>顺序</td>
<td>一般是玩家出牌顺序</td>
</tr>
<tr>
<td>报警</td>
<td>仍在场玩家</td>
<td>喊出UNO的动作</td>
</tr>
<tr>
<td>黑牌</td>
<td>牌</td>
<td>ACE和WILD牌，拥有最高级别自由度的两张牌，两张牌的颜色为“无颜色”</td>
</tr>
<tr>
<td>明牌</td>
<td>牌</td>
<td>牌面朝上的牌</td>
</tr>
</tbody>
</table>
<p>基础规则的一点说明：</p>
<ul>
<li>Wild
<ul>
<li>如果质疑成功，上家倒摸四张。但是变色效果始终生效。下家进入正常的行动回合。（出不了依然罚摸）</li>
<li>原则不是完全绝境【只有当没有和当前牌面颜色相同的牌时才能打出，花色同颜色不同的不算】</li>
</ul>
</li>
<li>draw TWO
<ul>
<li>下家罚摸后不能出牌</li>
</ul>
</li>
<li>基本回合不出牌时，罚摸的牌不能打出</li>
<li>solo时反转作为禁止</li>
</ul>
<p>过去常用的村规</p>
<ul>
<li>黑牌不能作最后一张牌</li>
<li>solo时</li>
</ul>
<h3 id="center叠加类变体center"><center>叠加类变体</center></h3>
<h4 id="center四色功能叠加center"><center>四色功能叠加</center></h4>
<blockquote>
<pre><code>  连对规则被引入游戏时，连对规则在叠加规则发动时不生效！（当手上有多张+2时，在叠加的环节，最多仍然只能出1张+2牌。）
</code></pre>
</blockquote>
<p>同花色的功能牌，可以叠加。生效于最后一名玩家</p>
<table>
<thead>
<tr>
<th>具体牌</th>
<th>特殊效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+2n</td>
<td>略</td>
</tr>
<tr>
<td>禁</td>
<td>最后一家摸n张，但是</td>
</tr>
<tr>
<td>快乐禁</td>
<td>所有禁放到一堆，最后一家的上家每回合额外将这张牌堆的牌打一张给下家，强制生效不可被叠加，直到打完</td>
</tr>
<tr>
<td>+4</td>
<td></td>
</tr>
</tbody>
</table>
<p>####<center>Wild叠加</center></p>
<blockquote>
<pre><code>  最后一家只能对第一张wild出牌者发出质疑。
</code></pre>
</blockquote>
<h3 id="量的变体">量的变体</h3>
<h4 id="更多选择xx默认为106x13">更多选择（x),x默认为10，6&lt;x&lt;13,</h4>
<p>玩家初始可以摸x张牌，可以观察后弃掉0-n张明牌，但最后的开局手牌数不得小于7<br>
注意：在洗牌之前，这些被弃的牌都要摆放好，方便部分玩家记牌</p>
<h3 id="玩家能力变体">玩家能力变体</h3>
<p>为了保留游戏的简洁性，不引入复杂的角色技能这样的玩法。<br>
而是引入几个小变体，将这些变体作为玩家的技能。选中技能的玩家才能使用该变体能力，在发动能力的时候需要说明。</p>
<p>包括：</p>
<ul>
<li>反转重铸</li>
<li>更多选择(12)</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[raw.githubusercontent.com的DNS污染小状况]]></title>
        <id>https://https://github.com/Egg12138/post/rawgithubusercontentcom-de-dns-wu-ran-xiao-zhuang-kuang/</id>
        <link href="https://https://github.com/Egg12138/post/rawgithubusercontentcom-de-dns-wu-ran-xiao-zhuang-kuang/">
        </link>
        <updated>2021-01-24T16:45:44.000Z</updated>
        <content type="html"><![CDATA[<p>175.44.115.198是我当时的ip<br>
在hosts中add:<br>
175.44.115.198 raw.githubusercontent.com</p>
<p>因为PC上的vpn太慢了，手机端的浏览器不能提取url的文件。所以只能从pc搞。<br>
不翻墙，只能改hosts。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C||My wrong-doings---0]]></title>
        <id>https://https://github.com/Egg12138/post/cormy-wrong-doings-0/</id>
        <link href="https://https://github.com/Egg12138/post/cormy-wrong-doings-0/">
        </link>
        <updated>2021-01-17T03:59:38.000Z</updated>
        <content type="html"><![CDATA[<p>#字符串方面<br>
char name[40];<br>
char newname[1];</p>
<p>printf( name, PARISE)<br>
print( newname ,name)<br>
first,scanf name = Egg12138<br>
then,scanf newname =Aydenegg<br>
output--&gt;<br>
异常表现：<br>
Hi,ydenegg(A没了）(本该是Egg12138,),PARISE words....<br>
在newname and name ouput中<br>
Hello,Aydenegg. ydenegg这里的问题就在于，newname正确接收并且存储了Aydenegg但是name的Egg12138成为了无首字母的ydenegg;</p>
<p>查资料前先测试一下：<br>
取消大写字母:依旧<br>
改变数组大小为32：有效<br>
char name[40];<br>
char newname[32];</p>
<p>现在压缩数组的大小，Aydenegg为8字母，改成8和7分别比较，尝试后发现只有char newname[1]的时候才会这样，并且字节长度我输入一个字母也如此</p>
<p>所以char [1]可能已经不是一个表卓的数组了，<br>
把char name[40] .--&gt; char name[1] output也一样……</p>
<p>查询：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的大一上]]></title>
        <id>https://https://github.com/Egg12138/post/wo-de-da-yi-shang/</id>
        <link href="https://https://github.com/Egg12138/post/wo-de-da-yi-shang/">
        </link>
        <updated>2021-01-10T06:11:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="心态很好的地方">心态很好的地方</h3>
<p>没有”被碾压“感。dalao很多，但是没有被碾压感，心里往往只有敬佩。那种卷的、一切都要靠疯狂竞争的心态在我心里没有位置，在我们学院也不是很严重（但是相当多人还是为了绩点和综测患得患失）</p>
<h3 id="最后谈一下内卷">最后谈一下内卷</h3>
<p>周围人对这个词的误解<br>
不是说竞争就教卷了，恶竞也和卷不一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C||simple-and-requently-used header files]]></title>
        <id>https://https://github.com/Egg12138/post/corsimple-and-requently-used-header-files/</id>
        <link href="https://https://github.com/Egg12138/post/corsimple-and-requently-used-header-files/">
        </link>
        <updated>2021-01-10T05:38:00.000Z</updated>
        <content type="html"><![CDATA[<p>std=standard</p>
<p>###<center> FILE: stdio.h     standard I/O</center></p>
<pre><code>int printf(const char *,...);
int scanf(const char *,...);
int getchar();  // read an charactor from the terminal
void putchar(char ch);  //output ch to the terminal
</code></pre>
<p>FILE *fopen(const char *file_path,const char *format);  open'file_path' as format format.</p>
<h3 id="centerfilestdlibh-standard-librarycenter"><center>FILE:stdlib.h    standard library</center></h3>
<p>void <em>calloc(size_t n,size_t size);<br>
/</em><br>
<em>在内存中连续分配n个长度为size的空间，并且return分配空间 首地址的指针<br>
**e.g.</em>: int *iList = (int *)alloc(10,sizeof(int)):<br>
<em>申请了大小为10 * sizeof(int)字节的连续空间</em>/</p>
<p>void <em>malloc(size_t size);<br>
/</em> 申请大小为size的连续空间 返回void    指针指向这段内存的初始地址，<br>
e.g: double <em>dList = (double</em>)malloce(sizeof(double) * 12);<br>
申请到大小为12 * sizeof(double)字节的空间</p>
<p>void free(void *ptr);<br>
/*释放pointer ,ptr所指向的内存空间<br>
<em>free(ptr);  ..使用calloc/malloc 申请的内存要free掉，否则会堆积</em>/</p>
<h3 id="file-stringh-stringstr">FILE:  string.h     string=str</h3>
<p>size_t strlen(const char *str);  return str pointD string长度，通过暴力遍历计数</p>
<p>bool strcmp(const char *strl,const char *str2);</p>
<p>char *strcat(char *str1, const char *str2); 这里的cat感觉功能上和bash shell的cat好像，应该是一个玩意儿，add。但是在terminal shell中cat还可以直接打开看单个文本文件。</p>
<p>char *strcpy(char *src,const char *dst)  //copy the data in dst(dest) to src</p>
<h3 id="ps">PS</h3>
<p>碎片的东西，放一点进来；</p>
<p>函数名前的 “ * ” 号，表示函数返回一个地址值；</p>
<pre><code>int *locate(){  //函数locate（）返回值保存在指针变量return中
    ......
}
</code></pre>
<p>c++的标准在98年确定，在那之前已经有一些库大量使用。<br>
新标准中，推出了名称空间的概念，既是为了方便人们使用新标准的同时，不用大量修改之前的代码，对之前的代码兼容，同时可以有效的避免名称冲突。<br>
旧标准中以.h结尾<br>
新标准没有.h<br>
旧标准中可以直接包含c的库文件，编译器会附带c的兼容库实现<br>
新标准中有一样的c库子模块支持，命名方式变更为：原stdio.h，新cstdio，即前面+c，后面去掉.h</p>
<p>C++语言也没有原生的字符串类型。C++语言通过C++标准库提供的string类型实现对字符串类型的支持。string类的特性如下：<br>
A、string直接支持字符串连接<br>
B、string直接支持字符串的大小比较<br>
C、string直接支持子串查找和提取<br>
D、string直接支持字符串的插入和替换</p>
<p>extern int i; //声明，不是定义<br>
int i; //声明，也是定义<br>
定义只能出现在一处。也就是说，不管是 int a 还是 int a=0 都只能出现一次，而 extern int a 可以出现很多次。<br>
当你要引用一个全局变量的时候，你就要声明 extern int a 这时候 extern 不能省略，因为省略了，就变成 int a 这是一个定义，不是声明。</p>
<p>下次做一个基础符号作用，是时候开始重新学C 了。<br>
<a href="https://en.cppreference.com/w/c/header">CPPreference-C standard library header</a></p>
]]></content>
    </entry>
</feed>