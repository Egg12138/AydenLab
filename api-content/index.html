{"posts":[{"title":"汇编python相关","content":"因为个人兴趣问题，matplotlib,numpy还有数据分析这些我不是很想搞，但是这些又是py的很有特点的第三方库，所以我放一点官方的资源。 在这些方面，大家应该是把py定位在一个“应用软件”的层次，所以，看看文档也基本都会了的。 可视化的经典库matplotlib 官网提供很多例子， ","link":"https://https://github.com/Egg12138/post/hui-bian-python-xiang-guan/"},{"title":"计算机组成原理||一篇选择性精要（坑，暑假填）","content":"基于冯诺依曼机的计算机 因为难度有点大，东西有点多，所以我只是略学一个大概 层次结构 Applications High-level programming language Assembler language Operating System Instruction Set Architecture &lt;我们关注这个及以下层次&gt; Passage指令集体系结构-CSDN Microcode Hardware 计算机系统性能评价 其他略 主频f = 外频 ×\\times× 倍频 &gt; Pentium4 f=2.4G, 2400M=133M ×\\times× 18 真正判准：CPU性能=IPC（周期内执行指令数量）×\\times× f, 主频大不一定性能更高 性能测试 ","link":"https://https://github.com/Egg12138/post/ji-suan-ji-zu-cheng-yuan-li-oryi-pian-xuan-ze-xing-jing-yao-keng-shu-jia-tian/"},{"title":"计算机组成原理||一篇选择性精要","content":"基于冯诺依曼机的计算机 因为难度有点大，东西有点多，所以我只是略学一个大概 层次结构 Applications High-level programming language Assembler language Operating System Instruction Set Architecture &lt;我们关注这个及以下层次&gt; Passage指令集体系结构-CSDN Microcode Hardware 计算机系统性能评价 其他略 主频f = 外频 ×\\times× 倍频 &gt; Pentium4 f=2.4G, 2400M=133M ×\\times× 18 真正判准：CPU性能=IPC（周期内执行指令数量）×\\times× f, 主频大不一定性能更高 性能测试 ","link":"https://https://github.com/Egg12138/post/ji-suan-ji-zu-cheng-yuan-li-oryi-pian-xuan-ze-xing-jing-yao/"},{"title":"Error Analysis & Uncertainties in Physical Measurements|| Some questions","content":"大疑问一：平方根规则，最小二乘法(MSE)， 最小绝对值法(MAE) 在John R. Taylor的书中，他指出： 当随机变量符合泊松分布的时候 v=vbest±σv=vbest ±vbest\\mathbf{v}=\\mathbf{v}_{\\mathbf{best}}\\pm \\sigma _{\\mathbf{v}}=\\mathbf{v}_{\\mathbf{best}\\,\\,}\\pm \\sqrt{\\mathbf{v}_{\\mathbf{best}}} v=vbest​±σv​=vbest​±vbest​​ 而用，平方和之根号？！==&gt;最小二乘法要求！ 为什么要选用最小二乘法？它有多重要？ 最小二乘法是十九世纪统计学的主题曲 从许多方面看来，它之于统计学就相当于十八世纪的微积分之于数学 -----*the history of statistics* 最小二乘法构造出的估计量优势在于： 三位一体 即同时满足： 这是在最小化欧几里得空间距离下的最优解； 这是满足条件概率下隐含的正交条件的最优解； 这是最大程度充分利用概率分布隐含信息条件下构造出的最优解。简单的说，是因为使用平方形式的时候，使用的是“最小二乘法”的思想，这里的“二乘”指的是用平方来度量观测点与估计点的距离（远近），“最小”指的是参数值要保证各个观测点与估计点的距离的平方和达到最小。 最小二乘法以估计值与观测值的平方和作为损失函数，在误差服从正态分布的前提下，与极大似然估计的思想在本质上是相同: 我们测得一系列点(xi,yi),现在为了求拟合的直线（猜想有那么一条）需要做如下几件事情1.定义一下这里的“真值”和“测量值”的bias2.假设有一条直线能够最大程度地减小Σbias,f(x)=ax+b3.计算出a,b如果我们假设x没有bias，那就只有y有bias，于是出现的bias就是竖直的所以在一个点的误差就是bi=∣f(xi)−yi∣,按照经验，用平方计算比较方便：从而Σbiases=∑i=1n(f(xi)−yi)2,展开得：∑ =S= ∑(axi+b−yi)2 ,这里的a,b为vars,∂∂a∑ (axi+b−yi)2 = ∂∂b∑ (axi+b−yi)2 = 0时S取得最小⇒2∑(axi+b−yi)xi=02∑(axi+b−yi)=0,以上我们得到最大似然。当随机变量符合正态分布的，时候这就是最可能的小误差拟合曲线我们再看Gilbert Strang的思路Ax = b,b在x的列空间。将测量列x变化成b真值列∥Ax−b∥2最小二乘是在欧氏距离为误差度量的情况下，由系数矩阵所张成的向量空间内对于观测向量的最佳逼近点。\\text{我们测得一系列点}\\left( x_i,y_i \\right) , \\text{现在为了求拟合的直线（猜想有那么一条）} \\\\ \\text{需要做如下几件事情} \\\\ \\\\ 1.\\text{定义一下这里的}“\\text{真值}”\\text{和}“\\text{测量值}”\\text{的}bias \\\\ 2.\\text{假设有一条直线能够最大程度地减小}\\Sigma bias, f\\left( x \\right) =ax+b \\\\ 3.\\text{计算出}a,b \\\\ \\\\ \\text{如果我们假设}x\\text{没有}bias\\text{，那就只有}y\\text{有}bias\\text{，于是出现的}bias\\text{就是竖直的} \\\\ \\text{所以在一个点的误差就是} b_i=\\left| f\\left( x_i \\right) -y_i \\right|, \\text{按照经验，用平方计算比较方便：} \\\\ \\text{从而}\\Sigma biases=\\sum_{i=1}^n{\\left( f\\left( x_i \\right) -y_i \\right) ^2},\\text{展开得：} \\\\ \\sum{\\,\\,}=S=\\,\\,\\sum{\\left( ax_i+b-y_i \\right) ^2}\\,\\,,\\text{这里的}a,b\\text{为}vars, \\\\ \\frac{\\partial}{\\partial a}\\sum{\\,\\,}\\left( ax_i+b-y_i \\right) ^2\\,\\,=\\,\\,\\frac{\\partial}{\\partial b}\\sum{\\,\\,}\\left( ax_i+b-y_i \\right) ^2\\,\\,=\\,\\,0\\text{时}S\\text{取得最小} \\\\ \\Rightarrow \\\\ 2\\sum{\\begin{array}{c} \\left( ax_i+b-y_i \\right) x_i\\\\ \\end{array}}=0 \\\\ 2\\sum{\\left( ax_i+b-y_i \\right) =0}, \\\\ \\text{以上我们得到最大似然。} \\\\ \\text{当随机变量符合正态分布的，时候这就是最可能的小误差拟合曲线} \\\\ \\\\ \\text{我们再看}Gilbert\\,\\,Strang\\text{的思路} \\\\ A\\boldsymbol{x}\\,\\,=\\,\\,\\boldsymbol{b}, \\boldsymbol{b}\\text{在}\\boldsymbol{x}\\text{的列空间。将测量列}x\\text{变化成}\\boldsymbol{b}\\text{真值列} \\\\ \\left\\| A\\boldsymbol{x}-\\boldsymbol{b} \\right\\| ^2 \\\\ \\\\ {\\color{red} \\mathbf{最小二乘是在欧氏距离为误差度量的情况下，}} \\\\ {\\color{red} \\mathbf{由系数矩阵所张成的向量空间内对于观测向量的最佳逼近点。}} \\\\ 我们测得一系列点(xi​,yi​),现在为了求拟合的直线（猜想有那么一条）需要做如下几件事情1.定义一下这里的“真值”和“测量值”的bias2.假设有一条直线能够最大程度地减小Σbias,f(x)=ax+b3.计算出a,b如果我们假设x没有bias，那就只有y有bias，于是出现的bias就是竖直的所以在一个点的误差就是bi​=∣f(xi​)−yi​∣,按照经验，用平方计算比较方便：从而Σbiases=i=1∑n​(f(xi​)−yi​)2,展开得：∑=S=∑(axi​+b−yi​)2,这里的a,b为vars,∂a∂​∑(axi​+b−yi​)2=∂b∂​∑(axi​+b−yi​)2=0时S取得最小⇒2∑(axi​+b−yi​)xi​​=02∑(axi​+b−yi​)=0,以上我们得到最大似然。当随机变量符合正态分布的，时候这就是最可能的小误差拟合曲线我们再看GilbertStrang的思路Ax=b,b在x的列空间。将测量列x变化成b真值列∥Ax−b∥2最小二乘是在欧氏距离为误差度量的情况下，由系数矩阵所张成的向量空间内对于观测向量的最佳逼近点。 &quot;WHY DO WE LOVE THE MSE?&quot;中说， MSE 它简单。 它提供了具有很好性质的相似度的度量。例如： 它是非负的; 唯一确定性。只有x=y的时候，d(x,y)=0； 它是对称的，即d(x,y)=d(y,x)； 符合三角性质。即d(x,z)&lt;=d(x,y)+d(y,z).3. 物理性质明确，在不同的表示域变换后特性不变，例如帕萨瓦尔等式。 便于计算。通常所推导得到的问题是凸问题，具有对称性，可导性。通常具有解析解，此外便于通过迭代的方式求解。 和统计和估计理论具有关联。在某些假设下，统计意义上是最优的。 作者：AlWeis 链接：https://www.zhihu.com/question/24095027/answer/30762001 来源：知乎,著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处 不确定度的传播 独立测量中和的不确定度， 问题在于，同时对x与y低估全部的xy的不确定度的可能性极其小，因此q=x+y中q的不确定度的值夸大了可能的误差。 σq=(σx)2+(σy)2会更加准确//即“正交相加”σ较小的时候，正交相加的表达式总小于绝对值相加的表达式σq=σx+σy，此所谓前面的“符合三角不等式”相加为极限：σq⩽σx+σy,在一些估算相对粗糙的情况下，确实可以直接将σq≈∑σi\\sigma \\boldsymbol{q}=\\sqrt{\\left( \\sigma \\boldsymbol{x} \\right) ^2+\\left( \\sigma \\boldsymbol{y} \\right) ^2}\\text{会更加准确}//\\text{即}\\boldsymbol{“}\\text{正交相加}\\boldsymbol{”} \\\\ \\sigma \\text{较小的时候，正交相加的表达式总小于绝对值相加的表达式}\\sigma \\boldsymbol{q}=\\sigma \\boldsymbol{x}+\\sigma \\boldsymbol{y}\\text{，此所谓前面的}\\boldsymbol{“}\\text{符合三角不等式}\\boldsymbol{”} \\\\ \\text{相加为极限：}\\sigma \\boldsymbol{q}\\leqslant \\sigma \\boldsymbol{x}+\\sigma \\boldsymbol{y},\\text{在一些估算相对粗糙的情况下，确实可以直接将}\\sigma \\boldsymbol{q}\\approx \\sum{\\sigma _{\\boldsymbol{i}}} σq=(σx)2+(σy)2​会更加准确//即“正交相加”σ较小的时候，正交相加的表达式总小于绝对值相加的表达式σq=σx+σy，此所谓前面的“符合三角不等式”相加为极限：σq⩽σx+σy,在一些估算相对粗糙的情况下，确实可以直接将σq≈∑σi​ 泊松分布简要 泊松分布带来“平方根规则”描述以随机方式出现，但却具有一定的平均率的计数事件的实验结果。e.g.氡气样品在10s的时间间隔内放射出的α粒子进行计数:P(νduring any given interval of time)=Pμ(ν)=e−μμνν!(μ&gt;0),μ为期望平均值νˉ=μ=RT,R为平均率，记住Pμ(ν)为计数事件在一次实验中得到结果ν的概率，以随机方式出现，但却具有一定的平均率的计数事件！ν的标准偏差到底为……？任何大量试验后的标准偏差都是从平均值中求出均方根偏差σν2=bar{(ν−νˉ)2}=(ˉν)2−(νˉ)2,参见P235我们得到ν=ν±ν \\text{泊松分布带来}\\boldsymbol{“}\\text{平方根规则}\\boldsymbol{”} \\\\ \\text{描述以随机方式出现，但却具有一定的平均率的计数事件的实验结果。}\\boldsymbol{e}.\\boldsymbol{g}.\\text{氡气样品在}10\\boldsymbol{s}\\text{的时间间隔内放射出的}\\alpha \\\\ \\text{粒子进行计数}:\\boldsymbol{P}\\left( \\nu _{\\boldsymbol{during}\\,\\,\\boldsymbol{any}\\,\\,\\boldsymbol{given}\\,\\,\\boldsymbol{interval}\\,\\,\\boldsymbol{of}\\,\\,\\boldsymbol{time}} \\right) =\\boldsymbol{P}_{\\mu}\\left( \\nu \\right) =\\boldsymbol{e}^{-\\mu}\\frac{\\mu ^{\\nu}}{\\nu !}\\left( \\mu &gt;0 \\right) ,\\mu \\text{为期望平均值} \\\\ \\bar{\\nu}=\\mu =\\boldsymbol{RT},\\boldsymbol{R}\\text{为平均率，} \\\\ \\text{记住}\\boldsymbol{P}_{\\mu}\\left( \\nu \\right) \\text{为计数事件在一次实验中得到结果}\\nu \\text{的概率，以随机方式出现，但却具有一定的平均率的计数事件！} \\\\ \\nu \\text{的标准偏差到底为}\\boldsymbol{……}\\text{？任何大量试验后的标准偏差都是从平均值中求出均方根偏差} \\\\ \\sigma _{\\nu}^2=\\boldsymbol{bar}\\left\\{ \\left( \\nu -\\bar{\\nu} \\right) ^2 \\right\\} =\\bar{(}\\nu )^2-\\left( \\bar{\\nu} \\right) ^2,\\text{参见}\\boldsymbol{P}235\\text{我们得到}\\nu =\\nu \\pm \\sqrt{\\nu} 泊松分布带来“平方根规则”描述以随机方式出现，但却具有一定的平均率的计数事件的实验结果。e.g.氡气样品在10s的时间间隔内放射出的α粒子进行计数:P(νduringanygivenintervaloftime​)=Pμ​(ν)=e−μν!μν​(μ&gt;0),μ为期望平均值νˉ=μ=RT,R为平均率，记住Pμ​(ν)为计数事件在一次实验中得到结果ν的概率，以随机方式出现，但却具有一定的平均率的计数事件！ν的标准偏差到底为……？任何大量试验后的标准偏差都是从平均值中求出均方根偏差σν2​=bar{(ν−νˉ)2}=(ˉ​ν)2−(νˉ)2,参见P235我们得到ν=ν±ν​ 一些初等运算的不确定合成 和差的不确定度：σq≈∑σiσq=∑(σi)2⩽∑σi幂的不确定度：q=xn=x⋅x⋅⋅⋅x,σq∣q∣=ηq≈ηx+ηxn−1=...=n⋅ηx⇒ηq≈n⋅σx∣x∣=n⋅(ηx)2积的不确定度：q=xy=(x±σx)×(y±σy)=xy±x⋅σy±σx⋅y±σx⋅σy≈xy±xy⋅σy∣y∣±xy⋅σx∣x∣=(xy)(best)(1+(σx∣x∣+σy∣y∣))=qbest(1+(ηx+ηy))=qbest(1+ηq)⇒ηq≈(ηx+ηy) 商的不确定度：q=a⋅b⋅c⋅⋅⋅mn⋅o⋅p⋅⋅⋅z,σq ≈ ∑ηletters ηq=σq∣q∣=∑ηletters2⩽∑ηletters 乘以常数的不确定度：q=Bx,σq=σx⋅B,但是由于B为常数不会有偏差，所以ηB=0e.g.t=1.6±0.1s;h=46.2±0.3ftg=2ht2=36.1ft/s2,ηg=η2+ηht⋅t=η2+(ηh+ηt2)=0+(ηh+2ηt)=0+(0.346.2+2⋅0.11.6) =0.131494≈13.1%若先估算两个η则答案为0.7%+2⋅6.3%=13.3%，这个估算的先后是以后说的事情儿。\\text{和差的不确定度：} \\\\ \\sigma \\boldsymbol{q}\\approx \\sum{\\sigma _{\\boldsymbol{i}}} \\\\ \\sigma \\boldsymbol{q}=\\sqrt{\\sum{\\left( \\sigma _{\\boldsymbol{i}} \\right)}^2}\\leqslant \\sum{\\sigma _{\\boldsymbol{i}}} \\\\ \\text{幂的不确定度：}\\boldsymbol{q}=\\boldsymbol{x}^{\\mathbf{n}}=\\boldsymbol{x}\\cdot \\boldsymbol{x}\\cdot \\cdot \\cdot \\boldsymbol{x},\\frac{\\sigma \\boldsymbol{q}}{\\left| \\boldsymbol{q} \\right|}=\\eta _{\\boldsymbol{q}} \\\\ \\approx \\eta _{\\boldsymbol{x}}+\\eta _{\\boldsymbol{x}^{\\boldsymbol{n}-1}}=...=\\boldsymbol{n}\\cdot \\eta _{\\boldsymbol{x}}\\Rightarrow \\eta _{\\boldsymbol{q}}\\approx \\boldsymbol{n}\\cdot \\frac{\\sigma \\boldsymbol{x}}{|\\boldsymbol{x}|} \\\\ =\\sqrt{\\boldsymbol{n}\\cdot \\left( \\eta _{\\boldsymbol{x}} \\right) ^2} \\\\ \\text{积的不确定度：}\\boldsymbol{q}=\\boldsymbol{xy}=\\left( \\boldsymbol{x}\\pm \\sigma \\boldsymbol{x} \\right) \\times \\left( \\boldsymbol{y}\\pm \\sigma \\boldsymbol{y} \\right) =\\boldsymbol{xy}\\pm \\boldsymbol{x}\\cdot \\sigma \\boldsymbol{y}\\pm \\sigma \\boldsymbol{x}\\cdot \\boldsymbol{y}\\pm \\sigma \\boldsymbol{x}\\cdot \\sigma \\boldsymbol{y} \\\\ \\approx \\boldsymbol{xy}\\pm \\boldsymbol{xy}\\cdot \\frac{\\sigma \\boldsymbol{y}}{|\\boldsymbol{y}|}\\pm \\boldsymbol{xy}\\cdot \\frac{\\sigma \\boldsymbol{x}}{|\\boldsymbol{x}|}=\\left( \\boldsymbol{xy} \\right) _{\\left( \\boldsymbol{best} \\right)}\\left( 1+\\left( \\frac{\\sigma \\boldsymbol{x}}{|\\boldsymbol{x}|}+\\frac{\\sigma \\boldsymbol{y}}{|\\boldsymbol{y}|} \\right) \\right) =\\boldsymbol{q}_{\\boldsymbol{best}}\\left( 1+\\left( \\eta _{\\boldsymbol{x}}+\\eta _{\\boldsymbol{y}} \\right) \\right) =\\boldsymbol{q}_{\\boldsymbol{best}}\\left( 1+\\eta _{\\boldsymbol{q}} \\right) \\\\ \\Rightarrow \\eta _{\\boldsymbol{q}}\\approx \\left( \\eta _{\\boldsymbol{x}}+\\eta _{\\boldsymbol{y}} \\right) \\,\\, \\\\ \\text{商的不确定度：}\\boldsymbol{q}=\\frac{\\boldsymbol{a}\\cdot \\boldsymbol{b}\\cdot \\boldsymbol{c}\\cdot \\cdot \\cdot \\boldsymbol{m}}{\\boldsymbol{n}\\cdot \\boldsymbol{o}\\cdot \\boldsymbol{p}\\cdot \\cdot \\cdot \\boldsymbol{z}},\\sigma \\boldsymbol{q}\\,\\,\\approx \\,\\,\\sum{\\eta _{\\boldsymbol{letters}}}\\,\\, \\\\ \\eta \\boldsymbol{q}=\\frac{\\sigma \\boldsymbol{q}}{\\left| \\boldsymbol{q} \\right|}=\\sqrt{\\sum{\\eta _{\\boldsymbol{letters}}^2}}\\leqslant \\sum{\\eta _{\\boldsymbol{letters}}}\\, \\\\ \\text{乘以常数的不确定度：}\\boldsymbol{q}=\\boldsymbol{Bx},\\sigma \\boldsymbol{q}=\\sigma \\boldsymbol{x}\\cdot \\boldsymbol{B},\\text{但是由于}\\boldsymbol{B}\\text{为常数不会有偏差，所以}\\eta _{\\boldsymbol{B}}=0 \\\\ \\boldsymbol{e}.\\boldsymbol{g}. \\\\ \\boldsymbol{t}=1.6\\pm 0.1\\boldsymbol{s};\\boldsymbol{h}=46.2\\pm 0.3\\boldsymbol{ft} \\\\ \\boldsymbol{g}=\\frac{2\\boldsymbol{h}}{\\boldsymbol{t}^2}=36.1\\boldsymbol{ft}/\\boldsymbol{s}^2,\\eta _{\\boldsymbol{g}}=\\eta _2+\\eta _{\\frac{\\boldsymbol{h}}{\\boldsymbol{t}\\cdot \\boldsymbol{t}}}=\\eta _2+\\left( \\eta _{\\boldsymbol{h}}+\\eta _{\\boldsymbol{t}^2} \\right) =0+\\left( \\eta _{\\boldsymbol{h}}+2\\eta _{\\boldsymbol{t}} \\right) = \\\\ 0+\\left( \\frac{0.3}{46.2}+2\\cdot \\frac{0.1}{1.6} \\right) \\,\\,=0.131494\\approx 13.1\\% \\\\ \\text{若先估算两个}\\eta \\text{则答案为}0.7\\%+2\\cdot 6.3\\%=13.3\\%，这个估算的先后是以后说的事情儿。 \\\\ \\\\ \\\\ 和差的不确定度：σq≈∑σi​σq=∑(σi​)2​⩽∑σi​幂的不确定度：q=xn=x⋅x⋅⋅⋅x,∣q∣σq​=ηq​≈ηx​+ηxn−1​=...=n⋅ηx​⇒ηq​≈n⋅∣x∣σx​=n⋅(ηx​)2​积的不确定度：q=xy=(x±σx)×(y±σy)=xy±x⋅σy±σx⋅y±σx⋅σy≈xy±xy⋅∣y∣σy​±xy⋅∣x∣σx​=(xy)(best)​(1+(∣x∣σx​+∣y∣σy​))=qbest​(1+(ηx​+ηy​))=qbest​(1+ηq​)⇒ηq​≈(ηx​+ηy​)商的不确定度：q=n⋅o⋅p⋅⋅⋅za⋅b⋅c⋅⋅⋅m​,σq≈∑ηletters​ηq=∣q∣σq​=∑ηletters2​​⩽∑ηletters​乘以常数的不确定度：q=Bx,σq=σx⋅B,但是由于B为常数不会有偏差，所以ηB​=0e.g.t=1.6±0.1s;h=46.2±0.3ftg=t22h​=36.1ft/s2,ηg​=η2​+ηt⋅th​​=η2​+(ηh​+ηt2​)=0+(ηh​+2ηt​)=0+(46.20.3​+2⋅1.60.1​)=0.131494≈13.1%若先估算两个η则答案为0.7%+2⋅6.3%=13.3%，这个估算的先后是以后说的事情儿。 我们继续再直观地感受以下直接加绝对值法和正交加法的区别。 P58: η电机=W电动机作W电动机收到=mghUIt,σg=0,σm,h,U,I=1%,σt=5%,由比值误差相加：ση电机η电机≈ηm+ηh+ηU+ηI+ηt=9%由正交加法：RHS=∑η2=29%≈5%估计明显小，而且我们知道，不确定度几乎总是要圆整到一位有效数字，正交法中我们发现在这种规则下，U,I,m,h没有贡献，能够非常强烈地突出t的5%的误差之影响此时我们可以看到σηη≈σtt=5%,需要注意一下量纲！！这里我们能够直接四则运算是因为我们都是用比值来运算！\\eta _{\\text{电机}}=\\frac{\\boldsymbol{W}_{\\text{电动机作}}}{\\boldsymbol{W}_{\\text{电动机收到}}}=\\frac{\\boldsymbol{mgh}}{\\boldsymbol{UIt}}, \\sigma _{\\boldsymbol{g}}=0,\\sigma _{\\boldsymbol{m},\\boldsymbol{h},\\boldsymbol{U},\\boldsymbol{I}}=1\\%,\\sigma _{\\boldsymbol{t}}=5\\%, \\\\ \\text{由比值误差相加：}\\frac{\\sigma _{\\eta _{\\text{电机}}}}{\\eta _{\\text{电机}}}\\approx \\eta _{\\boldsymbol{m}}+\\eta _{\\boldsymbol{h}}+\\eta _{\\boldsymbol{U}}+\\eta _{\\boldsymbol{I}}+\\eta _{\\boldsymbol{t}}=9\\% \\\\ \\text{由正交加法：} \\boldsymbol{RHS}=\\sqrt{\\sum{\\eta ^2}}=\\sqrt{29}\\%\\approx 5\\% \\\\ \\text{估计明显小，而且我们知道，不确定度几乎总是要圆整到一位有效数字，正交法中我们} \\\\ \\text{发现在这种规则下，}\\boldsymbol{U},\\boldsymbol{I},\\boldsymbol{m},\\boldsymbol{h}\\text{没有贡献，能够非常强烈地突出}\\boldsymbol{t}\\text{的}5\\%\\text{的误差之影响} \\\\ \\text{此时我们可以看到}\\frac{\\sigma _{\\eta}}{\\eta}\\approx \\frac{\\sigma _{\\boldsymbol{t}}}{\\boldsymbol{t}}=5\\%,\\text{需要注意一下量纲！！} \\\\ \\text{这里我们能够直接四则运算是因为我们都是用比值来运算！} η电机​=W电动机收到​W电动机作​​=UItmgh​,σg​=0,σm,h,U,I​=1%,σt​=5%,由比值误差相加：η电机​ση电机​​​≈ηm​+ηh​+ηU​+ηI​+ηt​=9%由正交加法：RHS=∑η2​=29​%≈5%估计明显小，而且我们知道，不确定度几乎总是要圆整到一位有效数字，正交法中我们发现在这种规则下，U,I,m,h没有贡献，能够非常强烈地突出t的5%的误差之影响此时我们可以看到ηση​​≈tσt​​=5%,需要注意一下量纲！！这里我们能够直接四则运算是因为我们都是用比值来运算！ 而再实际中，不同的物理量量纲完全独立开的话，我们完全有理由认为这些误差是独立的，然后再进行正交合成！ 如果是纯的加和，那么我们不必改用相对不确定度，因为这总是在一个量纲统一了的情况下进行的！ F=5+3+1量纲肯定都是N！所以可以直接对不确定进行加和 当微分时候——单变量函数由自变量微小不确定引起的不确定！q= 当 σx→0时\\sigma _x \\rightarrow 0 时σx​→0时, σq=q(xbest+σx)−q(xbest) →0denote it by∣q(x+Δx)−q(x)∣=∣dqdx∣Δx ≈ σq,从而将σq用解析的方式求出.Δx≈σx,当σx→0对于任意单变量函数q(x)，我们总可以用这种方式，求出一下极微小的自变量变差带来的q的不确定θ=(20±3)°,σcos⁡θ=∣−σθ⋅sin⁡θ∣=3°⋅sin⁡20°= 0.02(换成arg制)q=xn,σq=n⋅xn−1⋅σx ⇒ηq=n⋅σxx=n⋅ηx仍然成立\\sigma _{\\boldsymbol{q}}=\\boldsymbol{q}\\left( \\boldsymbol{x}_{\\boldsymbol{best}}+\\sigma _{\\boldsymbol{x}} \\right) -\\boldsymbol{q}\\left( \\boldsymbol{x}_{\\boldsymbol{best}} \\right) \\,\\,\\rightarrow 0 \\\\ \\boldsymbol{denote}\\,\\,\\boldsymbol{it}\\,\\,\\boldsymbol{by} \\\\ |\\boldsymbol{q}\\left( \\boldsymbol{x}+\\varDelta \\boldsymbol{x} \\right) -\\boldsymbol{q}\\left( \\boldsymbol{x} \\right) |=|\\frac{\\mathbf{d}\\boldsymbol{q}}{\\mathbf{d}\\boldsymbol{x}}|\\varDelta \\boldsymbol{x}\\,\\,\\approx \\,\\,\\sigma \\boldsymbol{q}, \\text{从而将}\\sigma \\boldsymbol{q}\\text{用解析的方式求出}. \\varDelta \\boldsymbol{x}\\approx \\sigma \\boldsymbol{x},\\text{当}\\sigma \\boldsymbol{x}\\rightarrow 0 \\\\ \\text{对于任意单变量函数}\\boldsymbol{q}\\left( \\boldsymbol{x} \\right) \\text{，我们总可以用这种方式，求出一下极微小的自变量变差带来的}\\boldsymbol{q}\\text{的不确定} \\\\ \\theta =\\left( 20\\pm 3 \\right) ^{\\degree}, \\sigma \\cos \\theta =|-\\sigma \\theta \\cdot \\sin \\theta |=3^{\\degree}\\cdot \\sin 20^{\\degree}=\\,\\,0.02\\left( \\text{换成}\\boldsymbol{arg}\\text{制} \\right) \\\\ \\boldsymbol{q}=\\boldsymbol{x}^{\\boldsymbol{n}}, \\sigma \\boldsymbol{q}=\\boldsymbol{n}\\cdot \\boldsymbol{x}^{\\boldsymbol{n}-1}\\cdot \\sigma \\boldsymbol{x}\\,\\,\\Rightarrow \\eta _{\\boldsymbol{q}}=\\frac{\\boldsymbol{n}\\cdot \\sigma \\boldsymbol{x}}{\\boldsymbol{x}}=\\boldsymbol{n}\\cdot \\eta _{\\boldsymbol{x}}\\text{仍然成立} σq​=q(xbest​+σx​)−q(xbest​)→0denoteitby∣q(x+Δx)−q(x)∣=∣dxdq​∣Δx≈σq,从而将σq用解析的方式求出.Δx≈σx,当σx→0对于任意单变量函数q(x)，我们总可以用这种方式，求出一下极微小的自变量变差带来的q的不确定θ=(20±3)°,σcosθ=∣−σθ⋅sinθ∣=3°⋅sin20°=0.02(换成arg制)q=xn,σq=n⋅xn−1⋅σx⇒ηq​=xn⋅σx​=n⋅ηx​仍然成立 常见到σxx=12σx∣x∣\\frac{\\sigma{\\sqrt{x}}}{\\sqrt{x}}=\\frac{1}{2} \\frac{\\sigma{x}}{|x|}x​σx​​=21​∣x∣σx​ 逐步传播 我们现在可以拆解误差传播中的问题为最基本的和差、积商、单变量函数…… 看复合的多变量函数q=x(y - z sinu), 我们换元q=x⋅ω,ω=y−zsin⁡uηq =(ηx)2+(ηω)2,然后同理展开算ηω ，又展开算zsin⁡u的不确定度\\text{我们换元} \\\\ \\boldsymbol{q}=\\boldsymbol{x}\\cdot \\omega ,\\omega =\\boldsymbol{y}-\\boldsymbol{z}\\sin \\boldsymbol{u} \\\\ \\eta _{\\boldsymbol{q}}\\,\\,=\\sqrt{\\left( \\eta _{\\boldsymbol{x}} \\right) ^2+\\left( \\eta _{\\omega} \\right) ^2}, \\\\ \\text{然后同理展开算}\\eta _{\\omega}\\,\\,\\text{，又展开算}\\boldsymbol{z}\\sin \\boldsymbol{u}\\text{的不确定度} \\\\ 我们换元q=x⋅ω,ω=y−zsinuηq​=(ηx​)2+(ηω​)2​,然后同理展开算ηω​，又展开算zsinu的不确定度 ","link":"https://https://github.com/Egg12138/post/error-analysis-and-uncertainties-in-physical-measurementsor-some-questions/"},{"title":"Operating System|| Interpreter, Parser, Lexer and Compiler","content":"A little section: Dynamic Language. The Python compiler knows relatively little about the effect the bytecode will have. It's up to the interpreter to determine the type of the object that BINARY_MODULO is operating on and do the right thing for that type. This is why Python is described as dynamically typed: you don't know the types of the arguments to this function until you actually run it. By contrast, in a language that's statically typed, the programmer tells the compiler up front what type the arguments will be (or the compiler figures them out for itself). Before the interpreter takes over,Python performs three other steps: Lexing Parsing Compiling Python is often called an \"interpreted\" language like Ruby or Perl, as opposed to a \"compiled\" language like C or Rust. However, this terminology isn't as precise as it may seem. Most interpreted languages, including Python, do involve a compilation step. The reason Python is called \"interpreted\" is that the compilation step does relatively less work (and the interpreter does relatively more) than in a compiled language. As we'll see later, the Python compiler has much less information about the behavior of a program than a C compiler does. A Tiny Python Interpreter in Python (500 lines or less) three instructions: LOAD_VALUE ADD_TWO_VALUES PRINT_ANSWER It's a stack machine, which must manipulate stacks to add two numbers 看到class Interpreter中 （用基于stack的方式来构建interpreter：这里我们喜欢用pop， 比如我们在stack中存储了a,b我们现在要调用a+b，就必须先弹出a，让b 成为顶部，再弹出b。pop的运算效率本身也比较高，而且每次都能清除用过的对象） to-execute{ instructions[ (load value, 0and1 , load name a and b, add vlauels,] numbers[7,5]就是七次+1，五次+1 names一一对应 } To keep track of what names are bound to what values, we'll add an environment dictionary to the init ** def init(self)😗* self.stack = [] self.environment = {} ** def LOAD_VALUE（接收参数value）** 将参数append倒stack去 确实是个stack结构呢！ ** def ADD_TWO_VALUES** 依次弹出读取stack的值， 然后， 把运算结棍return 回 stack的顶部 ** def PRINT_ANSWER ** 运算完成并且在stakc中完成存储后，现在再把答案弹出即可！ print answer可以作用其他很多运算的结果输出method，所以独立出来 ** def STORE_NAME（接收self，以及name）** stack弹出——所以要先有LOAD value！，stack存储的也多是value stack弹出赋给var， 于是name对应的值就应该是var， 正好作为dictionary存储到环境变量 self.environment[name] = var ** def LOAD_NAME(self, name)** 是store的逆过程，把env里的键值对的value存储到stack中 var = self.enr[name] self.stack.append(var) ** def parser(待解析的命令和参数以及参数命令dic)** &quot;&quot;&quot; Understand what the argument to each instruction means.&quot;&quot;&quot; 有关value的： numbers = [&quot;LOAD_VALUE&quot;] names = [&quot;LOAD_NAME&quot;, &quot;STORE_NAME&quot;] 进行parsing，将输入的命令instruction分配到位 if i in numbers argument = to-exe[&quot;numbers][argument]如果命令是属于数字录入的，那就将argument赋成to-exe字典中的&quot;numbers&quot;列表对应的数字 elif i in names: 对变量名操作，就可以再tp-exe[&quot;names][argument]里面搞 比如： to-exe: { &quot;numbers&quot;: [7, 5, 8], &quot;names&quot;: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] } 我们传递参数parser(&quot;LOAD_VALUE&quot;, arg=9，to-exe)参数解析后发现instruction对应于&quot;numbers&quot;,那么arg就被赋值为to-exe中的&quot;numbers&quot;:[arg]总觉得很奇怪……应该index回out of the range！ ","link":"https://https://github.com/Egg12138/post/operating-systemor-compiler/"},{"title":"Parity-Time-symmetric与WPT","content":"PTsymmetric P operator: T operator y = sinx + 1和y=0的关系就是conventional coupled system中gain/loss的大致关系 y = sinx + 1和y = -sin0.5x的关系就像是PTsymmetric system中gain/loss的大致关系 所以我们可以找到 x=arccos⁡1±338时最大x=\\mathrm{arc}\\cos \\frac{1\\pm \\sqrt{33}}{8}\\text{时最大} x=arccos81±33​​时最大 就不必追求到gain的最值处，或者 loss的最小处了。 WPT技术 经典WPT技术：MCT-WPT MCT−WPTPL = ∣ωkLTLRITRR+RL∣2RL ∝(ωk)2,ω为电源角频率，k为耦合系数要达到：ωSource=ωTransfer=ωReceive=ω0;η=PLΣP=RL(RR+RL)[RT(RR+RL)LTLR1(ωk)2+1]=1(1+RLRR)[RT(1+RLRR)LTLR1(ωk)2+1RR],when(RL≪RR),=1RTLTLR1(ωk)2=LTLRRT(ωk)2MCT-WPT \\\\ P_L\\,\\,=\\,\\,\\left| \\frac{\\omega k\\sqrt{L_TL_R}I_T}{R_R+R_L} \\right|^2R_L\\,\\,\\propto \\left( \\omega k \\right) ^2,\\omega \\text{为电源角频率，}k\\text{为耦合系数} \\\\ \\text{要达到：}\\omega _{Source}=\\omega _{Transfer}=\\omega _{\\mathrm{Re}ceive}=\\omega _0; \\\\ \\eta =\\frac{P_L}{\\Sigma P}=\\frac{R_L}{\\left( R_R+R_L \\right) \\left[ \\frac{R_T\\left( R_R+R_L \\right)}{L_TL_R}\\frac{1}{\\left( \\omega k \\right) ^2}+1 \\right]}=\\frac{1}{\\left( 1+\\frac{R_L}{R_R} \\right) \\left[ \\frac{R_T\\left( 1+\\frac{R_L}{R_R} \\right)}{L_TL_R}\\frac{1}{\\left( \\omega k \\right) ^2}+\\frac{1}{R_R} \\right]},when\\left( R_L\\ll R_R \\right) ,=\\frac{1}{\\frac{R_T}{L_TL_R}\\frac{1}{\\left( \\omega k \\right) ^2}}=\\frac{L_TL_R}{R_T}\\left( \\omega k \\right) ^2 \\\\ \\\\ \\\\ MCT−WPTPL​=∣∣∣∣​RR​+RL​ωkLT​LR​​IT​​∣∣∣∣​2RL​∝(ωk)2,ω为电源角频率，k为耦合系数要达到：ωSource​=ωTransfer​=ωReceive​=ω0​;η=ΣPPL​​=(RR​+RL​)[LT​LR​RT​(RR​+RL​)​(ωk)21​+1]RL​​=(1+RR​RL​​)[LT​LR​RT​(1+RR​RL​​)​(ωk)21​+RR​1​]1​,when(RL​≪RR​),=LT​LR​RT​​(ωk)21​1​=RT​LT​LR​​(ωk)2 ","link":"https://https://github.com/Egg12138/post/parity-time-symmetric-yu-wpt/"},{"title":"系统搭建记录","content":"WSL ubuntu vim editor中： .以vi 或者是vim开头编辑文件,输入命令之后,进入到编辑状态了。 .要退出,但是不保存,按esc先,然后输入【:q】,回车键即可退出,无法退出,则在【:q!... .要退出保存的 ,则~ 输入【:wq】,强制保存退出,则输入【:wq!】。 .看到此时已经退出, 在等待命令状态。 .以nano开头编辑文件的,则要退出,按【Ctrl+x】,回车键。如要保存的,则先按【Ctrl+o】,再按【x】退出 关于Compiler 再搭建编译环境中，要考虑到不同的标准下的情况 比如我写了ANSI风格的一个函数 报错=[Error] ld returned 1 exit status， 再编译器中勾选ANSI的标准就可以。 ","link":"https://https://github.com/Egg12138/post/xi-tong-da-jian-ji-lu/"},{"title":"一些英语注释用的词，组，句","content":"do these statements，执行这些语句 through the loop once执行一次这个循环， 语句千万不要随便用Sentence！ evaluate X,对X求值 increment只是递增 return to the beginning of the loop,一般略去定冠词:return to beginning of loop 被允许的可用C is not object to ... 见过语法，情况或者其他，最好用encounter ","link":"https://https://github.com/Egg12138/post/yi-xie-ying-yu-zhu-shi-yong-de-ci-zu-ju/"},{"title":"C语法基础表达和语句|","content":"data object lvalue, a label, some are modifiable, some are not. modifiable left-value = object locator value. C11suggested. rvalue, a real obj in the memories C标准const限定： 关键字const对变量的类型加以限定，使它的值不能被改变。 const对象一旦创建后其值就不能再改变，所以const对象必须初始化，如下： const int i = get_size(); //正确，在运行时初始化 const int j = 42; //正确，在编译时初始化 const int k; //不正确，k是一个未经初始化的常量 运算，操作的对象oper-and,operand称为项， 可以多重赋值: int j, t, c; c=t=j=68; OK,赋值顺序是68--&gt;j,t,c右至左 left-value = operate(l-value0,l-value1,...,l-valueN) ,operate(...)整体依然是个r-value; 对齐宽度 abc 1 对齐到C，宽度应该市%3而不是%2 1 $xx此处'&amp;'显然作为字符，1，2，3，4可以为循环体中的算子，%4d ---count是可以的， 2 $xx 3 $xx 4 $xx 截断truncation int:5/4 =&gt; 1; 6/3 = &gt; 2, 7/4 =&gt; 1; float: 7./4 值上= 7./4. =&gt; 1.75(%.2f) %d \\n&quot;,7./4.);报错 %d\\n&quot;,7./4);则不报错 灵活之处 相比python，C语法更灵活，感觉很棒~ 递增运算符 while (++shoe &lt; 42)， &lt;=&gt; while (shoe &lt; 42) {........++shoe}//根据下面的，这里判断的是递增后的shoe是否&lt; 42，即鞋码41为最后一个判断。 shoe++ &lt; 42则shoe达到42码时为最后一次循环。 > 即，shoe++会让shoe在与42比较之后再+1 **递增、比较与使用的顺序** while shoe++ < 45 printf(shoe) ** 此时先比较，(值优先)，再递增==>did第一个完整语句，再传递给printf** while shoe < 45 shoe++ printf... post_incresment ``a_post = a++: a_post = previous a and a += 1``,可以保留旧a，有时候返回旧a挺有用的。 ``pre_b = ++b: pre_b = new_b =b =previous b +1`` pre_incresment; decrement operator同理 for语句灵活 for的initialize不一定是赋值语句 for (printf(&quot;xxxx&quot;);test;update) update一定是在循环体执行完之后才进行的 for (printf(&quot;A!\\n&quot;);ch!='2';) scanf(&quot;%c&quot;,&amp;ch); printf(&quot;I like it!\\n&quot;); 还可以写成： for (printf....;ch!=...;scanf(&quot;%c&quot;,&amp;ch)) printf(i like it!) printf(Label)`` 发现输出有问题: A! Ilike it [two figures] I like it! I like it! [three figures] I like it! I like it I like it [fours figs: 1324] 则输出2个Ilikt it，然后输出Label， 可见，这里的sacnf会将输入转化成n个fig 发现bug，是忘了给循环体加入{}: 加入后： A! [sacnf abcs] I like it! Current cn is:a I like it! Current cn is:b I like it! Current cn is:c I like it! Current cn is:s I like it! Current cn is: 那么显然是声明时没有声明为数组…… 于是声明修改 char ch[4]加上scanf(&quot;%s&quot;,ch)在c的ISO中数组名就代表该数组的起始地址 混乱： dev-c++的TDM-GC 4.9.2下， n = 3 y = n++ + n++; printf(&quot;Now,y = %d, n = %d&quot;,y,n); y = n++ + ++n; printf(&quot;Now,y = %d, n = %d&quot;,y,n); output: y = 7(3+4), n =5 y=12(5+7),n=7，都是比previous n大了2， 可以看到再一个地方，编译器递增完立刻使用n，然后继续下一个递增。但是再别的编译器旧不一样了。这个结果C标准没定义， 要避开这种混乱，Don't be too clever! 这就是这种混乱的没有完整表达式的语句的问题4- 变量初始化 int sec; scanf%d==&gt;sec; while(sec &gt;0)[..scanf%d=sec] 这是很标准的方式，若不对sec进行初始化，int sec后，sec的垃圾值恰好就是0，直接都不会进入循坏！ 所以要么 * int sec = a number&gt;0 * 再while前面再添sacnf I/O 回车也是算input 在一个loop内，scanf--&gt; count++ 但是scanf会读取我两个字符，导致一个loop内，count会递增两次！ 缓冲 从键盘输入的所有字符被存到一个缓冲区,在调用getchar,getch,getche,scanf等函数时,电脑从这个缓冲区取,而不一定正好是在这个时候键盘输入的.(如果上次从键盘的输入和程序中要求的内容不一致时).清空之后,就是直接从这个时候由键盘输入的字符中读取了. fflush(stdin);（放在input之前就行，但是可能有的标准里没有这个语法，但不会报错） getchar()单个地读取缓冲区的数据，在inut之前插入getchar();或使用while((getchar())!='\\n');读取缓冲区字符直到结束后丢弃 看 Situation 0直接get &amp; put #include &lt;stdio.h&gt; int main(void) { char c; c = getchar(); putchar(c); system(&quot;pause&quot;); return 0; } IO和运行， 123as 1请按任意键继续. . . 这段程序只会从键盘里读取一个字符 整个过程大概如下： keyboard Input&quot;123as+Enter&quot;--&gt; Buffer : &quot;123as+Enter&quot; --getchar() read &quot;1&quot;--&gt;Assignment &quot;1&quot; to c --&gt; Putchar c onto screen --&gt; release &quot;1&quot;, leaving &quot;23as+Enter&quot; in the Buffer. Situation 1在循环体中，看上面一例的细节 char c; printf(&quot;The test is beginning&quot;); while ((c = getchar())!='3') { putchar(c); }`` system(&quot;pause&quot;); 结果： The test is beginning 2 &gt;2 22 &gt;22 11 &gt;11 1256456 &gt;1256456 123 &gt;12请按任意键继续. . .很显然这里执行的显然是”伪整体读取“，”仍然是 getchar由宏实现：#define getchar() getc(stdin)。getchar有一个int型的返回值，当程序调用getchar时，程序就等着用户按键。 用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止，当用户键入回车之后，getchar才开始从stdin流中每次弹出并且读入一个字符。 另一说法： 当我们输入txt的时候，不必去考虑如何分割开这些东西 我们的程序算法是 while (input != STOP sign) { words++;/这个是递增符/ 然后判断input这个单字母是否有特殊情况 } getchar()本身就是用来接受单个字符或者数组，要录入多个就输入数组 三类缓冲区类型 全缓冲； 行缓冲； 无缓冲； 条件 switch要注意到，如果没有适当地break或者coninue，各种switch的cases都会被执行…… ","link":"https://https://github.com/Egg12138/post/c-yu-fa-ji-chu-orbian-liang/"},{"title":"线性表复习|inPy","content":"先复习数组 int score[10]建了一个10容量的整型数组 for idx=0,idx++ printf score[idx] 注意到score[0]默认值为-1，（gcc4.9.2下） scanf的一些易错： scanf(&quot;%d\\n&quot;,&amp;a) ,scanf()中不允许使用换行 scanf(%7.2f,&amp;a),scanf()中不允许控制精度 scanf(&quot;%d&quot;,a),scanf()忘记加取d地址运算符 scanf(&quot;a=%d&quot;,&amp;a),scanf的一般格式 scanf(格式控制字符串，参数地址表)，所以不能在%d前面加a 使用单链表（ex_13) 这次没有顺序表的表演了 线性表 顺序表 链表LinkedList 在不连续的地址之间 A,B,C三个nodes之间有链接 Using the classical strategies: 是address而不是ptr！ [[Value]]&amp;[[add, like 0x34]] ---&gt;---[[Value1]]&amp;[[add1]]---&gt;---[[Value2]]&amp;[[add2]]--&gt;---[[Void]]&amp;[[ending]], Value or Element 单（向）链表，由指向add的ptr就可以得到整条链 单链表 operations: * is_empty() * len() * travel() * add(item) * append(x) * insert(pos * rm(x) * find(x), the x is the node. calss aNode elem Next node1: elem=10 next--point--&gt;node2 node2: elem=20 next--point--&gt;node3 address in py! a,b = b, a a tuple! 内存不变，只是a,b所指的地址变化。like ptr... 但是在C中，ab的指定就是对象本身 手动实现list obj的功能， 原理很简单了。 ","link":"https://https://github.com/Egg12138/post/xian-xing-biao-fu-xi-or-in-py/"},{"title":"自动化测试初步","content":"使用单链表（ex_13) 来完成 ","link":"https://https://github.com/Egg12138/post/zi-dong-hua-ce-shi-chu-bu/"},{"title":"脑洞|UNO变体规则","content":"首先，以下规则均出于增加游戏趣味性和难度的目的而作出的。 将会使用一些概念： 概念 对象 具体内涵 叠加 效果或牌 在上家的牌（或效果）生效前，打出符合（变体）规则的牌（或效果），并将这一系列牌的目标转移到下家 连对 一个玩家 将同一张牌打出多张 交换 交换效果目标（目标不一定是玩家持有的手牌） 将符合条件的牌（手牌，等）与目标 手牌 牌 玩家手上持有的牌，默认指的是集合，如交换A,B的手牌=交换A,B的所有受众持有的牌 抽取 牌 从目标区域中获得一定数量的牌 反转 顺序 一般是玩家出牌顺序 报警 玩家 喊出UNO的动作 黑牌 牌 ACE和WILD牌，拥有最高级别自由度的两张牌，两张牌的颜色为“无颜色” 明牌 牌 牌面朝上的牌 基础规则： Wild 如果质疑成功，上家倒摸四张。但但是变色效果始终生效。下家进入正常的行动回合。（出不了依然罚摸） 原则不是完全绝境【只有当没有和当前牌面颜色相同的牌时才能打出，花色同颜色不同的不算】 draw TWO 下家罚摸后不能出牌 基本回合不出牌时，罚摸的牌不能打出 solo时反转作为禁止 村规 黑牌不能作最后一张牌 solo时 叠加类变体 *n 连对规则被引入游戏时，连对规则在叠加规则发动时不生效！（当手上有多张+2时，在叠加的环节，最多仍然只能出1张+2牌。） 同花色的功能牌，可以叠加。生效于最后一名玩家 具体牌 特殊效果 +2n 略 禁 +4 量的变体 更多选择（x),x默认为10，6&lt;x&lt;13, 玩家初始可以摸x张牌，可以观察后弃掉0-n张明牌，但最后的开局手牌数不得小于7 注意：在洗牌之前，这些被弃的牌都要摆放好，方便部分玩家记牌 玩家能力变体 为了保留游戏的简洁性，不引入复杂的角色技能这样的玩法。 而是引入几个小变体，将这些变体作为玩家的技能。选中技能的玩家才能使用该变体能力，在发动能力的时候需要说明。 包括： 反转重铸 更多选择(12) ","link":"https://https://github.com/Egg12138/post/nao-dong-oruno-bian-ti-gui-ze/"},{"title":"|UNO变体规则","content":"首先，以下规则均出于增加游戏趣味性和难度的目的而作出的。 将会使用一些概念： 概念 对象 具体内涵 叠加 效果或牌 在上家的牌（或效果）生效前，打出符合（变体）规则的牌（或效果），并将这一系列牌的目标转移到下家 连对 牌 将同一张牌打出多张 交换 交换效果目标（目标不一定是玩家持有的手牌） 将符合条件的牌（手牌，等）与目标 手牌 牌 玩家手上持有的牌，默认指的是集合，如交换A,B的手牌=交换A,B的所有受众持有的牌 抽取 牌 从目标区域中获得一定数量的牌 反转 顺序 一般是玩家出牌顺序 报警 仍在场玩家 喊出UNO的动作 黑牌 牌 ACE和WILD牌，拥有最高级别自由度的两张牌，两张牌的颜色为“无颜色” 明牌 牌 牌面朝上的牌 基础规则的一点说明： Wild 如果质疑成功，上家倒摸四张。但是变色效果始终生效。下家进入正常的行动回合。（出不了依然罚摸） 原则不是完全绝境【只有当没有和当前牌面颜色相同的牌时才能打出，花色同颜色不同的不算】 draw TWO 下家罚摸后不能出牌 基本回合不出牌时，罚摸的牌不能打出 solo时反转作为禁止 过去常用的村规 黑牌不能作最后一张牌 solo时 叠加类变体 四色功能叠加 连对规则被引入游戏时，连对规则在叠加规则发动时不生效！（当手上有多张+2时，在叠加的环节，最多仍然只能出1张+2牌。） 同花色的功能牌，可以叠加。生效于最后一名玩家 具体牌 特殊效果 +2n 略 禁 最后一家摸n张，但是 快乐禁 所有禁放到一堆，最后一家的上家每回合额外将这张牌堆的牌打一张给下家，强制生效不可被叠加，直到打完 +4 ####Wild叠加 最后一家只能对第一张wild出牌者发出质疑。 量的变体 更多选择（x),x默认为10，6&lt;x&lt;13, 玩家初始可以摸x张牌，可以观察后弃掉0-n张明牌，但最后的开局手牌数不得小于7 注意：在洗牌之前，这些被弃的牌都要摆放好，方便部分玩家记牌 玩家能力变体 为了保留游戏的简洁性，不引入复杂的角色技能这样的玩法。 而是引入几个小变体，将这些变体作为玩家的技能。选中技能的玩家才能使用该变体能力，在发动能力的时候需要说明。 包括： 反转重铸 更多选择(12) ","link":"https://https://github.com/Egg12138/post/oruno-bian-ti-gui-ze/"},{"title":"raw.githubusercontent.com的DNS污染小状况","content":"175.44.115.198是我当时的ip 在hosts中add: 175.44.115.198 raw.githubusercontent.com 因为PC上的vpn太慢了，手机端的浏览器不能提取url的文件。所以只能从pc搞。 不翻墙，只能改hosts。 ","link":"https://https://github.com/Egg12138/post/rawgithubusercontentcom-de-dns-wu-ran-xiao-zhuang-kuang/"},{"title":"C||My wrong-doings---0","content":"#字符串方面 char name[40]; char newname[1]; printf( name, PARISE) print( newname ,name) first,scanf name = Egg12138 then,scanf newname =Aydenegg output--&gt; 异常表现： Hi,ydenegg(A没了）(本该是Egg12138,),PARISE words.... 在newname and name ouput中 Hello,Aydenegg. ydenegg这里的问题就在于，newname正确接收并且存储了Aydenegg但是name的Egg12138成为了无首字母的ydenegg; 查资料前先测试一下： 取消大写字母:依旧 改变数组大小为32：有效 char name[40]; char newname[32]; 现在压缩数组的大小，Aydenegg为8字母，改成8和7分别比较，尝试后发现只有char newname[1]的时候才会这样，并且字节长度我输入一个字母也如此 所以char [1]可能已经不是一个表卓的数组了， 把char name[40] .--&gt; char name[1] output也一样…… 查询： ","link":"https://https://github.com/Egg12138/post/cormy-wrong-doings-0/"},{"title":"我的大一上","content":"心态很好的地方 没有”被碾压“感。dalao很多，但是没有被碾压感，心里往往只有敬佩。那种卷的、一切都要靠疯狂竞争的心态在我心里没有位置，在我们学院也不是很严重（但是相当多人还是为了绩点和综测患得患失） 最后谈一下内卷 周围人对这个词的误解 不是说竞争就教卷了，恶竞也和卷不一样。 ","link":"https://https://github.com/Egg12138/post/wo-de-da-yi-shang/"},{"title":"C||simple-and-requently-used header files","content":"std=standard ### FILE: stdio.h standard I/O int printf(const char *,...); int scanf(const char *,...); int getchar(); // read an charactor from the terminal void putchar(char ch); //output ch to the terminal FILE *fopen(const char *file_path,const char *format); open'file_path' as format format. FILE:stdlib.h standard library void calloc(size_t n,size_t size); / 在内存中连续分配n个长度为size的空间，并且return分配空间 首地址的指针 **e.g.: int *iList = (int *)alloc(10,sizeof(int)): 申请了大小为10 * sizeof(int)字节的连续空间/ void malloc(size_t size); / 申请大小为size的连续空间 返回void 指针指向这段内存的初始地址， e.g: double dList = (double)malloce(sizeof(double) * 12); 申请到大小为12 * sizeof(double)字节的空间 void free(void *ptr); /*释放pointer ,ptr所指向的内存空间 free(ptr); ..使用calloc/malloc 申请的内存要free掉，否则会堆积/ FILE: string.h string=str size_t strlen(const char *str); return str pointD string长度，通过暴力遍历计数 bool strcmp(const char *strl,const char *str2); char *strcat(char *str1, const char *str2); 这里的cat感觉功能上和bash shell的cat好像，应该是一个玩意儿，add。但是在terminal shell中cat还可以直接打开看单个文本文件。 char *strcpy(char *src,const char *dst) //copy the data in dst(dest) to src PS 碎片的东西，放一点进来； 函数名前的 “ * ” 号，表示函数返回一个地址值； int *locate(){ //函数locate（）返回值保存在指针变量return中 ...... } c++的标准在98年确定，在那之前已经有一些库大量使用。 新标准中，推出了名称空间的概念，既是为了方便人们使用新标准的同时，不用大量修改之前的代码，对之前的代码兼容，同时可以有效的避免名称冲突。 旧标准中以.h结尾 新标准没有.h 旧标准中可以直接包含c的库文件，编译器会附带c的兼容库实现 新标准中有一样的c库子模块支持，命名方式变更为：原stdio.h，新cstdio，即前面+c，后面去掉.h C++语言也没有原生的字符串类型。C++语言通过C++标准库提供的string类型实现对字符串类型的支持。string类的特性如下： A、string直接支持字符串连接 B、string直接支持字符串的大小比较 C、string直接支持子串查找和提取 D、string直接支持字符串的插入和替换 extern int i; //声明，不是定义 int i; //声明，也是定义 定义只能出现在一处。也就是说，不管是 int a 还是 int a=0 都只能出现一次，而 extern int a 可以出现很多次。 当你要引用一个全局变量的时候，你就要声明 extern int a 这时候 extern 不能省略，因为省略了，就变成 int a 这是一个定义，不是声明。 下次做一个基础符号作用，是时候开始重新学C 了。 CPPreference-C standard library header ","link":"https://https://github.com/Egg12138/post/corsimple-and-requently-used-header-files/"},{"title":"力学||简单汇编一下振动的微分方程的几种解","content":"阻尼震动 在有阻尼的情况下：fγ=−γv,策动力F0=F0(t)先考察F0=0的情况：mx¨=−kx−γx˙⇒mx¨+γx˙+kx=0⇒x¨+γmx˙+kmx=0又km=ω0,我们可以对偶地设一个量β=γm,当然量纲为平方倍x¨+2βx˙+ω02x=0⇒ x′′+2βx′+ω02x=0一个二阶常系数线性齐次微分方程看到特征方程λ2+2βλ+ω2=0λ=−2β±4β2−4ω022=−β±β2−ω2两个实根λ1,λ2⇒解空间S=span(eλ1x,eλ2x)重根λ⇒S=span(eλx,xeλx)共轭负根λ1,2=a±bi,即λ=−2β±2β2−ω022=−2β±2iω2−β2 2=−β±ω2−β2iS=eax(span(cos⁡bx,sin⁡bx))=再由欧拉公式展开我们统一采用振动的复数表示：x~=A~eiωt=A~(cos⁡ωt+isin⁡ωt)x~˙=A~eiωtiω,x~¨=−A~eiωtω2(=ω⃗×(ω⃗×x⃗))⇒ω2−i 2βω−ω02=0,一切都变得更简单了继续：弱阻尼β≪ω,γ小的时候，x=A0(e−βtcos⁡(ωt+φ0))临界阻尼β≈ω,x=(C1+C2t)e−βt过阻尼β&gt;ω,x=C1eβ2−ω2t−βt+C2e−β2−ω2t−βt=e−βt(C1ept+C2e−pt),p=β2−ω2\\text{在有阻尼的情况下：} \\\\ f_{\\gamma}=-\\gamma v, \\text{策动力}F_0=F_0\\left( t \\right) \\\\ \\text{先考察}F_0=0\\text{的情况} \\text{：} \\\\ m\\ddot{x}=-kx-\\gamma \\dot{x}\\Rightarrow m\\ddot{x}+\\gamma \\dot{x}+kx=0\\Rightarrow \\ddot{x}+\\frac{\\gamma}{m}\\dot{x}+\\frac{k}{m}x=0 \\\\ \\text{又}\\sqrt{\\frac{k}{m}}=\\omega _0,\\text{我们可以对偶地设一个量}\\beta =\\frac{\\gamma}{m},\\text{当然量纲为平方倍} \\\\ \\ddot{x}+2\\beta \\dot{x}+\\omega _0^2x=0 \\Rightarrow \\,\\,x\\prime\\prime+2\\beta x\\prime+\\omega _0^2x=0\\text{一个二阶常系数线性齐次微分方程} \\\\ \\text{看到特征方程}\\lambda ^2+2\\beta \\lambda +\\omega ^2=0 \\\\ \\lambda =\\frac{-2\\beta \\pm \\sqrt{4\\beta ^2-4\\omega _0^2}}{2}=-\\beta \\pm \\sqrt{\\beta ^2-\\omega ^2} \\\\ \\text{两个实根}\\lambda _1,\\lambda _2\\Rightarrow \\text{解空间}S=span\\left( e^{\\lambda _1x},e^{\\lambda _2x} \\right) \\\\ \\text{重根}\\lambda \\Rightarrow S=span\\left( e^{\\lambda x},xe^{\\lambda x} \\right) \\\\ \\text{共轭负根}\\lambda _{1,2}=a\\pm bi,\\text{即}\\lambda =\\frac{-2\\beta \\pm 2\\sqrt{\\beta ^2-\\omega _0^2}}{2}=\\frac{-2\\beta \\pm 2i\\sqrt{\\omega ^2-\\beta ^2}\\,\\,}{2}=-\\beta \\pm \\sqrt{\\omega ^2-\\beta ^2}i \\\\ S=e^{ax}\\left( span\\left( \\cos bx,\\sin bx \\right) \\right) =\\text{再由欧拉公式展开} \\\\ \\\\ \\\\ \\text{我们统一采用振动的复数表示：} \\\\ \\tilde{x}=\\tilde{A}e^{i\\omega t}=\\tilde{A}\\left( \\cos \\omega t+i\\sin \\omega t \\right) \\\\ \\dot{\\tilde{x}}=\\tilde{A}e^{i\\omega t}i\\omega ,\\ddot{\\tilde{x}}=-\\tilde{A}e^{i\\omega t}\\omega ^2\\left( =\\vec{\\omega}\\times \\left( \\vec{\\omega}\\times \\vec{x} \\right) \\right) \\\\ \\Rightarrow \\omega ^2-i\\,\\,2\\beta \\omega -\\omega _0^2=0,\\text{一切都变得更简单了} \\\\ \\\\ \\text{继续：} \\\\ \\text{弱阻尼}\\beta \\ll \\omega , \\gamma \\text{小的时候，}x=A_0\\left( e^{-\\beta t}\\cos \\left( \\omega t+\\varphi _0 \\right) \\right) \\\\ \\text{临界阻尼}\\beta \\approx \\omega ,x=\\left( C_1+C_2t \\right) e^{-\\beta t} \\\\ \\text{过阻尼}\\beta &gt;\\omega ,x=C_1e^{\\sqrt{\\beta ^2-\\omega ^2}t-\\beta}t+C_2e^{-\\sqrt{\\beta ^2-\\omega ^{2t}}-\\beta t}=e^{-\\beta t}\\left( C_1e^{pt}+C_2e^{-pt} \\right) ,p=\\sqrt{\\beta ^2-\\omega ^2} \\\\ \\\\ 在有阻尼的情况下：fγ​=−γv,策动力F0​=F0​(t)先考察F0​=0的情况：mx¨=−kx−γx˙⇒mx¨+γx˙+kx=0⇒x¨+mγ​x˙+mk​x=0又mk​​=ω0​,我们可以对偶地设一个量β=mγ​,当然量纲为平方倍x¨+2βx˙+ω02​x=0⇒x′′+2βx′+ω02​x=0一个二阶常系数线性齐次微分方程看到特征方程λ2+2βλ+ω2=0λ=2−2β±4β2−4ω02​​​=−β±β2−ω2​两个实根λ1​,λ2​⇒解空间S=span(eλ1​x,eλ2​x)重根λ⇒S=span(eλx,xeλx)共轭负根λ1,2​=a±bi,即λ=2−2β±2β2−ω02​​​=2−2β±2iω2−β2​​=−β±ω2−β2​iS=eax(span(cosbx,sinbx))=再由欧拉公式展开我们统一采用振动的复数表示：x~=A~eiωt=A~(cosωt+isinωt)x~˙=A~eiωtiω,x~¨=−A~eiωtω2(=ω×(ω×x))⇒ω2−i2βω−ω02​=0,一切都变得更简单了继续：弱阻尼β≪ω,γ小的时候，x=A0​(e−βtcos(ωt+φ0​))临界阻尼β≈ω,x=(C1​+C2​t)e−βt过阻尼β&gt;ω,x=C1​eβ2−ω2​t−βt+C2​e−β2−ω2t​−βt=e−βt(C1​ept+C2​e−pt),p=β2−ω2​ 受迫振动 在有阻尼的情况下：fγ=−γv,策动力F0=F0(t)现在考察F0不为0的情况：mx¨=−kx−γx˙⇒mx¨+γx˙+kx=F(t)⇒x¨+γmx˙+kmx=F(t)令策动力为简谐力F =F0cos⁡(ωt),此处ωf即前面所求的β2−ω02,意义很明显是由阻尼因子引起的而且发现他们有勾股的关系，f的方向与转动速度垂直β=γmx¨+2βx˙+ω02x=F0mcos⁡(ωt) ⇒ x′′+2βx′+ω02x=F0mcos⁡(ωt)一个二阶常系数线性齐次微分方程我不会解……⇒x=A0e−βtcos⁡(ω1t+φ0)+Acos⁡(ωft+φ)这个结构就可以分解成振幅成指数衰减的振动和恒定振动，能量来源是策动力和阻力的合力。值得注意的是，策动力并不总是做正功。⇒稳定状态：x=Acos⁡(ωf+φ),A=f0(ω02−ωf2)+4β2ωf2)=f0(ω02−ωf2)+4β2ωf2)=不稳定状态\\text{在有阻尼的情况下：} \\\\ f_{\\gamma}=-\\gamma v, \\text{策动力}F_0=F_0\\left( t \\right) \\\\ \\text{现在考察}F_0\\text{不为}0\\text{的情况} \\text{：} \\\\ m\\ddot{x}=-kx-\\gamma \\dot{x}\\Rightarrow m\\ddot{x}+\\gamma \\dot{x}+kx=F\\left( t \\right) \\Rightarrow \\ddot{x}+\\frac{\\gamma}{m}\\dot{x}+\\frac{k}{m}x=F\\left( t \\right) \\\\ \\text{令策动力为简谐力}F\\,\\,=F_0\\cos \\left( \\omega t \\right) ,\\text{此处}\\omega _f\\text{即前面所求的}\\sqrt{\\beta ^2-\\omega _0^2},\\text{意义很明显是由阻尼因子引起的} \\\\ \\text{而且发现他们有勾股的关系，}f\\text{的方向与转动速度垂直} \\\\ \\beta =\\frac{\\gamma}{m} \\\\ \\ddot{x}+2\\beta \\dot{x}+\\omega _0^2x=\\frac{F_0}{m}\\cos \\left( \\omega t \\right) \\,\\,\\Rightarrow \\,\\,x\\prime\\prime+2\\beta x\\prime+\\omega _0^2x=\\frac{F_0}{m}\\cos \\left( \\omega t \\right) \\text{一个二阶常系数线性齐次微分方程} \\\\ \\text{我不会解}……\\Rightarrow x=A_0e^{-\\beta t}\\cos \\left( \\omega _1t+\\varphi _0 \\right) +A\\cos \\left( \\omega _ft+\\varphi \\right) \\\\ \\text{这个结构就可以分解成振幅成指数衰减的振动和恒定振动，能量来源是策动力和阻力的合力。值得注意的是，策动力并不总是做} \\\\ \\text{正功。} \\\\ \\Rightarrow \\\\ \\text{稳定状态：}x=A\\cos \\left( \\omega _f+\\varphi \\right) ,A=\\frac{f_0}{\\sqrt{\\left( \\omega _0^2-\\left. \\omega _f^2 \\right) +4\\beta ^2\\omega _f^2 \\right)}}=\\frac{f_0}{\\sqrt{\\left( \\omega _0^2-\\left. \\omega _f^2 \\right) +4\\beta ^2\\omega _f^2 \\right)}}= \\\\ \\text{不稳定状态} \\\\ \\\\ \\\\ \\\\ 在有阻尼的情况下：fγ​=−γv,策动力F0​=F0​(t)现在考察F0​不为0的情况：mx¨=−kx−γx˙⇒mx¨+γx˙+kx=F(t)⇒x¨+mγ​x˙+mk​x=F(t)令策动力为简谐力F=F0​cos(ωt),此处ωf​即前面所求的β2−ω02​​,意义很明显是由阻尼因子引起的而且发现他们有勾股的关系，f的方向与转动速度垂直β=mγ​x¨+2βx˙+ω02​x=mF0​​cos(ωt)⇒x′′+2βx′+ω02​x=mF0​​cos(ωt)一个二阶常系数线性齐次微分方程我不会解……⇒x=A0​e−βtcos(ω1​t+φ0​)+Acos(ωf​t+φ)这个结构就可以分解成振幅成指数衰减的振动和恒定振动，能量来源是策动力和阻力的合力。值得注意的是，策动力并不总是做正功。⇒稳定状态：x=Acos(ωf​+φ),A=(ω02​−ωf2​)+4β2ωf2​)​f0​​=(ω02​−ωf2​)+4β2ωf2​)​f0​​=不稳定状态 ","link":"https://https://github.com/Egg12138/post/li-xue-orjian-dan-hui-bian-yi-xia-zu-ni-zhen-dong-de-wei-fen-fang-cheng-de-ji-chong-jie/"},{"title":"Py_collections||命令行参数","content":"'''python #!/user/Shaw/Python38 python3 import argparse ''' 'import argparse' 命令行参数复习 * positional arguments * optional arguments ARGPARSE模块 先讨论 'argparse'[1]库，这个词是解析器的意思，顾名思义 框架 '''python3 import argparse parser = argparse.ArgumentParser(description='Process some integers.') parser.add_argument('integers', metavar='N', type=int, nargs='+', help='an integer for the accumulator') parser.add_argument('--sum', dest='accumulate', action='store_const', const=sum, default=max, help='sum the integers (default: find the max)') args = parser.parse_args() print(args.accumulate(args.integers))''' 如上示例，argparse模块的基本使用包含5个步骤： import模块：import argparse 获解析器对象：argparse.ArgumentParser 利用解析器对象内建方法，添加参数解析规则：add_argument 利用解析器对象内建方法，开始解析参数，获取解析结果对象：parse_args 从解析结果对象中，获取参数值：parse_args 在命令行中可以愉快有玩耍parse_args，可以及时获得反馈， 比如我创建一个parse: Namespace(Love='siqilin', foo='a')为初始，现在可以直接，在命令行中parse.parse_args('-Love agirl',split()) 此处的method是str数据类型的属性mathod usage: PROG [-h] [--foo [FOO]] bar [bar ...] #prog程序名 and usage bar help #description功能描述 positional arguments: #required bar bar help optional arguments: #optional -h, --help show this help message and exit --foo [FOO] foo help And that's how you'd foo a bar #epilog补充描述字段，拿来收尾也很好 解析器对象的属性 默认值 功能 大致方法 prog sys.argv[0] '-h' 时显示程序名称 ... usage - usage字段描述 ... description None des描述 ... epilog None 补充字段描述 ... parents None 从父解析器中继承所有参数选项 ... formatter_class None 定制说明文本的显示风格 ... prefix_class - 定制前缀字符，例如前缀&quot;-b&quot;改为“+b&quot; ... add_help True 是否使能显示参数 -h --help ... allow_abbrev True 是否支持长参数 ... fromfile_prefix_chars None 略 ... argument_default None 略 ... conflict_handler None 略 ... 代码部分 构建解析器实例对象 `parser = argparse.ArugumentParser(description='Optional参数')生成这个对象之后就可以给parser对象添加参数属性 class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True) 自带的可选形参列表：创建实例部分 description&amp;epilogepilog搞additional descriptions，在’HELP之尾部 #实例创建的这几个参数不是位置参数，但是习惯上prog&gt;usage&gt;des&gt;epilog,因为help呈现的顺序就是这样 prog=... ，默认是用sys.argv[0]，但是可以自定义，为-h显示时的程序名。 usage=...,默认呈现-,但是可以自定义， 可以用filename.py -h来调出这个des，也可以用' parser.print_help()' parents会提取ArgumeentParser的所有参数列表，并且获取其中所有的positional and optional actions 然后让其他的解析器可以继承参数。 `parser = argpaarse.ArugumentParser(description='Des',epilog='Additional words') metavar name or flags：也就是在使用参数的时候使用的符号，--foo 或者 -f这样的预定为optional argument。 解析器会自行完成这份工作。bar,+bar则自动成为positional aruguments, action：根据我的理解，这个属性可以选择参数在只提供符号而不输入实际的值的时候给予一个默认的值action的default action是 'Store' nargs：这个属性规定了参数可以输入的个数,nargs默认为1，所以默认值为1的时候输入的量不能带空格（那样的话，会杯视为下一个参数命令） narg=+会类似*kargs parser = argparse.ArgumentParser(prog='PROG') parser.add_argument('foo', nargs='+') parser.parse_args(['a', 'b']) Namespace(foo=['a', 'b']) parser.parse_args([]) usage: PROG [-h] foo [foo ...] PROG: error: the following arguments are required: foo * const：这属性跟 action 属性一起使用 * default：这属性就是给参数设置一个默认值 * type：这个属性规定了参数的数据类型 * choices：这个属性给参数限定了一个选择的迭代，参数只能在这个范围内选择参数的值，否则报错 * required：参数的值为必填 filling 一个parser making calls to add_argument(): 基本info的存储和使用的调用 making calls to parse_args() args=parer.parse_args() prefix_chars +a: add_argument('+a')会出现在positional arguments一栏， ++a:同+a理 argparse是一个多数py版本都会自带的一个命令行参数解析库 ↩︎ ","link":"https://https://github.com/Egg12138/post/py_collectionsorming-ling-xing-can-shu/"},{"title":"辩|| 灌论","content":"&gt; 关键一、是由于自己想的论点，前因后果，自己最明白。故自己提问，往往会质疑的「太有水准」。 那些（对你而言）太基本、太天真、太粗糙、太琐碎或答案太理所当然的问题，你当然不会问。 于是，队友也不会答。 好比你说：「比起行万里路，读万卷书的好处，是知识比较全面。」 然后，你开始跟队友（学弟妹）们攻防起书本里的知识哪里哪里全面？全面有什么什么好处？可 以怎么怎么解决人类生死存亡的大问题……行万里路，又是如何如何的见树不见林？ 结果比赛时，对手搔搔头，问到：「抱歉，请问您方所谓的『知识』，到底是什么意思？」 信不信，恰恰正是这种蠢问题，会让你的宝贝队友（学弟妹）听完一愣！ 当下，他们只好凭一己之常识，临场回应——而同队中，这或许重要或许不重要的常识落差，便 是口径不统一，弹道走偏的开始。 常常，我们会觉得队友（学弟妹）很笨，不能理解他们怎么会**「在这么简单的问题上」**犯错？ 有时，实在冤枉 少爷讲的这段话确实很对。以后的备赛和学习，都要回归到最基础的地方去。 ","link":"https://https://github.com/Egg12138/post/bian-or-guan-lun/"},{"title":"Py_collections|一些内置关键字 模块","content":"yield与生成器 “不执行函数代码，而是返回一个generator对象，这个对象是可迭代对象， 具有next()方法，调用一次next方法执行到yield那里的时候暂停一下，返回一次计算的值(用法类似return)， 当再次调用next()方法时，接着yield下面代码循环执行知直到又碰到yield， 返回下一个循环计算的值从而实现动态生成值。 在Pythoncookbook4.3中，作者给出了比较好的机制展示： def c(n):while n &gt; 0: print(&quot;Count from:&quot;,n)n -= 1 print('Done')c(5) 这是定义一个常规的函数，当然用for最快，此处是为了对比 现在： def countdown(n): print(&quot;Countfrom:&quot;, n) while n&gt;0: yield n n -= 1 print('Done') sys module 常用单元 sys.argv：以列表的方式获取运行 Python 程序的命令行参数存放其中。其中 sys.argv[0] 通常就是指该 Python程序本身，sys.argv[1] 代表第一个参数，sys.argv[2] 代表第二个参数，以此类推。类似于 Shell 中的 $0、$1、$2 import sys print('程序名称为：{}，第一个参数为：{}，第二个参数为：{}'.format(sys.argv[0], sys.argv[1], sys.argv[2])) sys.byteorder：显示本地字节序的指示符。如果本地字节序的大端模式，则该属性返回big，否则返回little sys.copyright：该属性返回与 Python 解释器有关的版权信息 sys.executable：该属性返回 Python 解释器在磁盘上的存储路径 sys.exit()：通过引发SystemExit异常来退出程序，将其放在try块中不能阻止finally块的执行。 sys.flags：该只读属性返回运行Python命令时指定的旗标 sys.getfilesystemencodiing()：返回在当前系统中保存文件所用的字符集 sys.getrefcount()：返回指定对象的引用计数。 sys.getrecursionlimit()：返回Python解释器当前支持的递归深度。该属性可通过setrecursionlimit()方法重新设置 sys.getswitchinterval()：返回在当前Python解释器中线程切换的时间间隔。该属性可通过setswitchinterval()函数改变 sys.implementation：返回当前Python解释器的实现 sys.maxsize：返回Python整数支持的最大值。在32位平台上，该属性值为 2 ×× 31-1；在64位平台上，该属性值为 2 ×× 63-1 sys.path：该属性指定Python查找模块的路径列表。程序可通过修改该属性来动态增加Python加载模块的路径 sys.platfrom：返回Python解释器所在的平台的标识符 sys.stdin：返回系统的标准输入流——一个类文件对象 sys.stdout：返回系统的标准输出流——一个类文件对象 sys.stderr：返回系统的错误输出流——一个类文件对象 sys.version：返回当前Python解释器的版本信息 sys.winver：返回当前Python解释器的主版本号 sys.copyright：返回当前Python解释器的版权信息 ","link":"https://https://github.com/Egg12138/post/py_collectionsoryi-xie-nei-zhi-guan-jian-zi/"},{"title":"半定量物理|量纲","content":"对于细棒： 用量纲进行一些定量分析：[I] = ML2⇒I = ml2Φ{Π};要注意到，Φ{Π}是无量纲比值参量；（是齐次式）我们记k = Φ{Π},I = k ml2,于是k=k(shape);如果要在物理上刻画出k，利用的比较多的是η,σ,ρ进行积分的策略；其实是求出Ic等量，此处用量纲来解，显然就直接利用Ic等量就可以了；于是，联立更多方程：C在细棒的中点处，由平行轴定理：I = (k+14)ml2现在进行质心的翻译：对半每一段m2,l2,他们绕原中点，现断点的O的转动惯量：I2′ = I1′ = 18(k+14)ml2I = I1′ + I2′ = 28(k+14)ml2回代得到I = 112ml2;Ic = 13ml2在舒幼生的力学中也能找到不少这样的求转动惯量的题目\\text{用量纲进行一些定量分析：} \\\\ \\left[ I \\right] \\,\\,=\\,\\,\\mathrm{ML}^2\\Rightarrow I\\,\\,=\\,\\,ml^2\\Phi \\left\\{ \\Pi \\right\\} ; \\\\ \\text{要注意到，}\\Phi \\left\\{ \\Pi \\right\\} \\text{是无量纲比值参量；（是齐次式）} \\\\ \\text{我们记}k\\,\\,=\\,\\,\\Phi \\left\\{ \\Pi \\right\\} , I\\,\\,=\\,\\,k\\,\\,ml^2,\\text{于是}k=k\\left( shape \\right) ; \\\\ \\text{如果要在物理上刻画出}k\\text{，利用的比较多的是}\\eta ,\\sigma ,\\rho \\text{进行积分的策略；} \\\\ \\text{其实是求出}I_c\\text{等量，此处用量纲来解，显然就直接利用}I_c\\text{等量就可以了；} \\\\ \\text{于是} \\text{，联立更多方程：} \\\\ C\\text{在细棒的中点处，由平行轴定理：} \\\\ I\\,\\,=\\,\\,\\left( k+\\frac{1}{4} \\right) ml^2 \\\\ \\text{现在进行质心的翻译：} \\\\ \\text{对半每一段}\\frac{m}{2},\\frac{l}{2},\\text{他们绕原中点，现断点的}O\\text{的转动惯量：} \\\\ I_2&#x27;\\,\\,=\\,\\,I_1&#x27;\\,\\,=\\,\\,\\frac{1}{8}\\left( k+\\frac{1}{4} \\right) ml^2 \\\\ I\\,\\, =\\,\\,I_1&#x27;\\,\\,+\\,\\,I_2&#x27;\\,\\,=\\,\\,\\frac{2}{8}\\left( k+\\frac{1}{4} \\right) ml^2 \\\\ \\text{回代得到}I\\,\\,=\\,\\,\\frac{1}{12}ml^2;I_c\\,\\,=\\,\\,\\frac{1}{3}ml^2 \\\\ \\text{在舒幼生的力学中也能找到不少这样的求转动惯量的题目} \\\\ \\\\ 用量纲进行一些定量分析：[I]=ML2⇒I=ml2Φ{Π};要注意到，Φ{Π}是无量纲比值参量；（是齐次式）我们记k=Φ{Π},I=kml2,于是k=k(shape);如果要在物理上刻画出k，利用的比较多的是η,σ,ρ进行积分的策略；其实是求出Ic​等量，此处用量纲来解，显然就直接利用Ic​等量就可以了；于是，联立更多方程：C在细棒的中点处，由平行轴定理：I=(k+41​)ml2现在进行质心的翻译：对半每一段2m​,2l​,他们绕原中点，现断点的O的转动惯量：I2′​=I1′​=81​(k+41​)ml2I=I1′​+I2′​=82​(k+41​)ml2回代得到I=121​ml2;Ic​=31​ml2在舒幼生的力学中也能找到不少这样的求转动惯量的题目 参考： 赵凯华《定性与半定量物理》 ","link":"https://https://github.com/Egg12138/post/ban-ding-liang-wu-li-orliang-gang/"},{"title":"Py_collections|3.10的类型注释更新","content":" 引入&quot;|&quot;操作符，like &quot;or&quot; def foo(x int | float): return x *math.pi foo(1) #pass foo(1.22)#pass foo('a string text')# annotation error 还有一个比较号，之前遇到过错误的，就是类型的alias别名 这次引入了新方法解决了 text = &quot;has been defined&quot; from typing_extensions import TypeAlias TempType: TypeAlias = &quot;T_T&quot; or TempType: TypeAlias = text, TempType要被识别为一个类型名，这个很重要 Zip的严格匹配False, True,（等长标记） x有n个，y有n-1个，过去zip(x,y)进行列表化，list(zip(x,y))后，得到的是n-1对。。 但是现在可以严格化，匹配等长 zip(x,y).strict = True ，放在Try except里面，就可以实现比较简洁的等长匹配结构 ","link":"https://https://github.com/Egg12138/post/py_collectionsor310-de-lei-xing-zhu-shi-geng-xin/"},{"title":"Py_collections|字符串相关","content":"正式投入format怀抱 在一次getsocketbyname()的测试中，我先用Format来运行，很正常，然后输出了hostname + ip,很明显不是string, 然后我用%s试了一次……果然报错了。不过这个案例不重要…… 这篇文章也不会是我自己主笔，靠的ctrl+C和Ctrl+v (2333333333) string objs have one uni BIOperation :the % modulo.,which is also known as 'formatting or interpolation' operator. If format requires a single argument, values may be a single non-tuple object. 5 Otherwise, values must be a tuple with exactly the number of items specified by the format string, or a single mapping object (for example, a dictionary. it's syntax is complicated... print('%(language)s has %(number)03d quote types.' % {'language': &quot;Python&quot;, &quot;number&quot;: 2}) Python has 002 quote types. here 03d is familiar,right? 03d ==&gt; 3fig integer, #我们总要声明%格式化对象的类型 文章主体来自一个国内blog,和python doc 自从Python2.6引入了format这个格式化字符串的方法之后，我认为%还是format这根本就不算个问题。 # 定义一个坐标值 c = (250, 250) # 使用%来格式化 s1 = &quot;敌人坐标：%s&quot; % c 上面的代码很明显会抛出一个如下的TypeError： TypeError: not all arguments converted during string formatting 像这类格式化的需求我们需要写成下面的格式才行： # 定义一个坐标值 c = (250, 250) # 使用%丑陋的格式化... s1 = &quot;敌人坐标：%s&quot; % (c,) 而使用format就不会存在上面的问题： # 定义一个坐标值 c = (250, 250) # 使用format格式化 s2 = &quot;敌人坐标：{}&quot;.format(c) 很显然，format比%方便多了。 blogger输入一个tuple c，用%(c)格式化的时候%s,无法be converted! %(c,)才行 ，它 传递一个元组 在使用%插入多个变量时，tuple是不可避免的，这样会让代码冗杂 它还不能正确地现实元组和字典 而format语法： print(&quot;{}:{}&quot;.format(host, gethostbyname()))清晰易读 注意，在不是f-strings的时候，不能在{}内输入东西？ f-strings把变量放在里面，大大提高了代码可读性 f-strings name = 'xxx' age = 18 uni = 'SYSU' city = 'Zhuhal','China' 可以看一下 text0 =&quot;My name is %s,aged%d.I am educated in %s, %s&quot;%(name,age,uni,city) text1='Ma name is {},aged{}.I am educated in {},{}'.format(name,age,uni,city) textf = f&quot;My name is {name},aged{age}.I am educated in {uni},{city}&quot; f-string采用 {content:format} 设置字符串格式，其中 content 是替换并填入字符串的内容，可以是变量、表达式或函数等，format是格式描述符。采用默认格式时不必指定 {:format}，如上面例子所示只写 {content} 即可。 nval = self.next and self.next.value or None return f&quot;[{self.value}:{repr(nval)}]&quot; f-string大括号内也可填入lambda表达式，但lambda表达式的 : 会被f-string误认为是表达式与格式描述符之间的分隔符，为避免歧义，需要将lambda表达式置于括号 () 内： &gt;&gt;&gt; f'result is {lambda x: x ** 2 + 1 (2)}' File &quot;&lt;fstring&gt;&quot;, line 1 (lambda x) ^ SyntaxError: unexpected EOF while parsing &gt;&gt;&gt; f'result is {(lambda x: x ** 2 + 1) (2)}' 'result is 5' &gt;&gt;&gt; f'result is {(lambda x: x ** 2 + 1) (2):&lt;+7.2f}' 'result is +5.00 ' --- Class中的__repr__&amp;str class Car(): '' def init(self,color): self.color = color def __repr__(self): return '__repr__ for Car' def __str__(self): return '__str__ for Car' mC = Car('red') mC print(mC) str(mC) str([mC]) '' 在print(mC)时，返回__str__内容 而在call mC时，返回__repr__内容。 所以在命令行中直接调用mC的得到结果就是‘repr for Car' 如果没有__repr__，在命令行中直接call mC会弹出内存地址，总归不那么舒适。 打印或直接调用 str() 方法也能得到相同的结果，因为 str 的默认实现就是调用 repr 方法。上面的(str([mC]))的结果就是'repr for Car' print(mC) print(str(mC)) print(str([mC])) print(type(mC)) print(type([mC])) repr(mC) 》》》分别对应的输出 str for Car str for Car [repr for Car] &lt;class 'main.Car'&gt; &lt;class 'list'&gt; 'repr for Car' ","link":"https://https://github.com/Egg12138/post/py_collectionsorzheng-shi-tou-ru-format-de-huai-bao/"},{"title":"|菜狗算法入门|开心数","content":"A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits in base-ten, and repeat the process until the number either equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. Those numbers for which this process ends in 1 are happy numbers, while those that do not end in 1 are unhappy numbers. Given a list of numbers, classify each of them as happy or unhappy. 思路其实蛮简单，但是我一开始写的程序time out了，算法的时间复杂度太高。 n = int(input()) def getsum(num): rest = divmod(num,10) #会return一个list，包含整数商和余数 t0 = rest[0] t1 = rest[1] return t02+t12 for i in range(n): x = int(input()) if x == 1: print(&quot;%d 😃&quot; %(x)) break else: tempsum = getsum(x) ali = [] while True: ali.append(tempsum) tempsum = getsum(tempsum) if tempsum in ali == True: print(&quot;%d :(&quot; %(x)) break elif tempsum == 1: print(&quot;%d :)&quot; %(x)) break Write an answer using print 这是一份愚蠢的代码。 我们来看看要怎么优化 ","link":"https://https://github.com/Egg12138/post/orcai-gou-suan-fa-ru-men-orkai-xin-shu/"},{"title":"|菜狗算法| 时间复杂度","content":" 两数和，哈希表优化时间复杂度 先看一下leetcode提供的一个解法。 我也是这个思路（因为考虑到暴力枚举连代码行数都很多……） 但是这里有一个优化，就是在返回序列上面， leetcode提供 的答案里面直接用enumerate(nums) &gt;&gt;return 一个hashtable 我则因为不会标准的hashtable，手动地用index 遍历 len(nums),,再判断 Target - number0 in List.... class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashtable = dict() for i, num in enumerate(nums): if target - num in hashtable: return [hashtable[target - num], i] hashtable[nums[i]] = i return [] 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/two-sum/solution/ liang-shu-zhi-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 队列有筛选表 from collections import deque from time import time def main1(n): leftadd = n+100 q = [] q.append(n^3) q.append(n^2) print(q) q.append('_') for i in range(len(q)-1): q[-i-1] = q[-i-2] q[0] = leftadd 像左部添加元素的操作就需要遍历数组，O(n) def main(n): q = deque() q.append(n^3) q.append(n^2) print(q) q.appendleft(n+100) q.popleft() 这几个单独的操作时间复杂度都是O(1) s = time() for i in range(10): main(i) e = time() print(e-s) s=time() for i in range(10): main1(i) e=time() print(e-s) p ","link":"https://https://github.com/Egg12138/post/orsuan-fa-or-liang-shu-he-ha-xi-biao-you-hua-shi-jian-fu-za-du/"},{"title":"Ver.0.0.1 宿舍公约","content":"宿舍公约草案 ⅰ作息和生活篇 /作息 1.熄灯允许时间为23:30-7:00？8:00？和12:00-14:00。该时段内，若宿舍成员数大于1，成员可在不引起争议的前提下熄灯。宿舍仅一人时，熄灯不受限制。 2.一般情况下，噪声盖过三档风扇的噪声即为过大。须禁止。 3.有室友睡眠时，噪声盖过一档风扇即为过大。须禁止 /生活噪声 4.床具噪音，肖和黄的宿舍床因结构问题噪声较大，需限制上下床动作幅度： 不得全掌贴地跳跃下床 上床事人体重心尽量偏向过道 **有必要对门进行维修，门的噪声过大** 5.有宿舍成员睡眠时，某些行为需受限，包括但不限于： 开柜幅度减小、开拉门速度减慢、卫生间闭门开水、底噪走路、湿拖鞋走路不用全掌直接着地的方式、不在阳台和卫生间之外的场所洗漱。 /生活洗漱 6.非特殊情况下，洗衣机不允许放入：内裤、鞋、袜、纸类和其他洗衣无关的物体。 7.洗衣机尽量一次洗完当日衣服。 8.一般情况下，室内允许挂置干燥物品，不允许晾晒任何纺织品。 9.最后一名更衣的宿舍成员有义务启动洗衣机。 10.对于拖延不晾晒的成员的衣物，若有干扰阳台活动的，其他成员可以合理地移动该衣物，但需要声明。 11.当日不清洁衣物者，需提前告知。 /水电物质 1.宿舍购置物品本学年由俊哲同学负责，大学四年轮流来负责，顺序可参考宿舍打扫卫生的顺序。允许同学们申请负责或不负责该项事务，但需自己找好另一位同学来填补空缺。是否准许需通过群体表决。 2.打水倒垃圾等，原则上轮流进行，满则倒，水空则换。不作严格要求。 ⅱ宿舍面貌和卫生篇 宿舍面貌的维护包括但不限于： 宿舍（含卫生间和阳台）保洁、宿舍垃圾倾倒、堆积杂物（快递盒等）定期清理、宿舍气味。 /保洁 1.保洁轮流进行： 周一肖俊哲， 周三贺天楷， 周五黄肖鸿， 周日罗丁溢。 遗忘者，需要调整补做。 2.保洁基本内容：扫地和拖地。不定期统一进行宿舍扫除： 暂定每月15号进行，包含四项基本内容：扫地，拖地，阳台清洁，厕所清洁。每个人负责一项。 /垃圾卫生 3.不允许在宿舍他人领域就餐。 4.宿舍就餐必须及时清洗餐具。 5.及时处理易腐败物质。 6.个人快递盒，外卖盒，包裹包装等归属个人垃圾，不允许长时间挤占过道空间。 ⅲ其他的个人权利与义务篇 1.宿舍成员有在协商后、或按照宿舍内习惯不影响他人权利的前提下进行不受干扰的个人行为的权利. 2.宿舍成员有个人隐私信息和个人隐私空间的所有权。 宿舍成员不得在未经取得对方允许的的情况下查看其他宿舍成员的物件，包括但不限于：笔记本，电子产品，抽屉等。 **空调遥控器需要放到外部** 宿舍成员不得在未经对方允许的情况下侵入其他宿舍成员的个人空间：床位、桌位和衣柜 对于洗衣机内衣物 3.宿舍成员有义务共同保持宿舍卫生 4.不谈论各人成绩，绩点等。宿舍时生活的场所。各位宿舍成员有保持求同存异观念的义务。 5，各位同学有权讨论问题，相互请教，但有义务保持适度，不可一问不可收拾。 ","link":"https://https://github.com/Egg12138/post/ver001-su-she-gong-yue/"},{"title":"辩||2019新国辩 东吴-爱丁堡前半部分的简单回顾","content":"两轮立论和质询： +1论点 肥胖是发达国家的社会问题，需要被处理 多并发症 国家经济负担 含C饮料危害大，与肥胖关联紧密 量超标 游离糖-肥胖基因表达 C饮料零饱腹感 成瘾性 +内脏脂肪 针对C的征收政策取得了实际效益 征税--&gt;C量- 征税--&gt;Sale(C饮料)-,Sale(水等)+ 权威 ***-1质询 *** 质疑肥胖的诱病性，提出肥胖与表现并发症受同g控制的观点，试拆肥胖有问题这一点。 -1论点 肥胖不是那么严重的问题 肥胖悖论 有危害更大的X，认为不必 征税 糖。 肥胖税的社会恶性影响 偷换讨征税对象为垃圾食品。以H，J食品对穷人 的生活负担 （反方除了赖长生，基本都再偷换含糖饮料 +1 二辩 已经顺着林圣伟的质询，拆掉了反一的立论。 * 提出肥胖程度问题，弱化肥胖悖论的力度（但是这点正方一直没有拿下来，正方后来本来抓到了原论文的”超重体重”!= 反方“肥胖“，但是居然拿了个内脏脂肪的说法。 本来可以从体脂率，肌肉率等来拆解。） * 引用权威，强调糖是严重问题。(这里是很简单的思路：含糖饮料是一个非常严重问题，必须要管制，至于这个盐类隐患，她重要性再高，也不会影响其他重要健康政策的实行。PS:这样会留下一个漏洞，就是”既然我可以对某些盐类食品征税，那我的健康食品补助就可以不从肥胖税来，这样就没必要为了补贴而去征收肥胖税“) * 强调严重肥胖现象的社会恶劣影响—，防住了反方对于”行为自由“的攻击，提出积极的自由 * 真---受身打法，节目效果很好。 -3质询 三辩的进攻非常有效，正二给反方递了很多刀子。 质询成果： 1. 让正二对销量下降。群体。解释出现明显漏洞（还好关于这一点后来+四辩又捞回来了） 2. 偷换正二选择含糖饮料为征税对象 理由。 先归谬，给出”挤占资源，自身伤害，经济负担“的例子 3. 扰乱+2思路，使其说出，”难执行，不征税“的话，并且模糊他对 4. 再归谬，逼迫正二说出”这个对你不好，对别人不好“，所以 5. 强化了3，给出了长寿税…… 6. 政府管制的正当性， -2论点 略 +3质询 略 -3小结 用”无标准“来弱化正方的论证力度 重申同g导致obe&amp;并发症 对+2的”死亡率低的obe患者，消耗更多的医疗资源“ ，从检测上面进行拆解 引入代糖（反方在代糖危害，在科学事实上面的漏洞其实很明显，代糖只需要添加很少量就有超高甜度，那么即便它单位量对人的危害略高于碳水化合物，微量 的它和能够造成同样甜度的大量的糖相比，几乎可以被视作使没有危害。） 4 . +3小结 比她自己的质询好多了。。。 用C诱发肥胖等疾病表达基因的数据 用幸福回应了长寿等 将自由和幸福主动拉上战场 …… ","link":"https://https://github.com/Egg12138/post/bian-or2019-xin-guo-bian-dong-wu-ai-ding-bao-qian-ban-bu-fen-de-jian-dan-hui-gu/"},{"title":"摘|| 加缪的去英雄主义","content":" 但是笔者更愿意相信，过分重视高尚行为，结果反而会变成对罪恶简洁而有力的褒扬。因为那样做会让人猜想，高尚行为如此可贵只因它寥若晨星，所以狠心和冷漠才是人类行为更经常的动力。而这种想法正式笔者不能苟同的。人世间的 罪恶几乎总是由愚昧造成，人如果缺乏教育，好心也可能同恶意一样造成损害。好人比恶人多，而实际上那并非症结之所在。人有无知和更无知的区别，着'就叫道德或不道德，最令人厌恶的不道德是愚昧无知，无知的人认为自己无所不知，因而自认有权杀人。杀人凶手的心灵是盲目的，而没有远见卓识就不会有真正的善和高尚的爱—《鼠疫》 如果善都需要过分地强调与歌颂，那是很虚伪的、很没有温情的！因为善是我们都应该做的，不是需要克服多少艰难就应该被表现出来的的。里厄医生等人，他们的所作所为是职责之所在，是当下之最优解，不需要捧起来说英雄。 对抗疫情，医生上前，这就是医生的职责，我们尊重他们，传承善，而不需要将别人高高捧起，这不是冷漠，这是人文情怀 ","link":"https://https://github.com/Egg12138/post/zhai-or-jia-mou-0/"},{"title":"Py_Collection||Network Programming||0","content":"现在准备从Onenote把精要转过来（Md的编辑其实远远没有Onenote方便）。以前的东西国庆期间再来转移。 Requests Packages pip install即可。 import 时，发现载入更花（相对）时间——这个库比较大。 help(requests) Help on package requests: NAME requests DESCRIPTION Requests HTTP Library ~~~~~~~~~~~~~~~~~~~~~ Requests is an HTTP library, written in Python, for human beings. Basic GET usage: &gt;&gt;&gt; import requests &gt;&gt;&gt; r = requests.get('https://www.python.org') &gt;&gt;&gt; r.status_code 200 &gt;&gt;&gt; b'Python is a programming language' in r.content True ... or POST: &gt;&gt;&gt; payload = dict(key1='value1', key2='value2') &gt;&gt;&gt; r = requests.post('https://httpbin.org/post',data=payload) &gt;&gt;&gt; print(r.text) { ... &quot;form&quot;: { &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot; }, ... } PACKAGE CONTENTS __version__ _internal_utils adapters api auth certs compat cookies exceptions help hooks models packages sessions status_codes structures utils 先看初级help的几个内容 get()函数时再很多库中都有。r = request.get(URL)来获取网络资源 ","link":"https://https://github.com/Egg12138/post/py_collectionornetwork-programmingor0/"},{"title":"关于社团/会的问题","content":"首先，我要明确我要加入大约两个忙碌程度中等的社团。 其次，我需要明确还有哪些”约“式的爱好者社团，将这些社团安排好，使适应1-2个的主社团/部门和课业安排 组织策划办事的 * 物天学生会的学术部门 * 中大GBT的活动策划（舞台控制等等a）------特点是考试周一般没有活动 * 团委 志愿组(活动不少) 后台编辑的（但是没有程序设计和网站运维的……） * 物天新媒体 的编辑 * 中大GBT的宣传，----- 学习性的 * 物天新媒体中心 ，编辑稿件 * 中大GBT的制作方面,------&gt;Photoshop等图像处理 爱好 * 辩论(! 时间花费很多 !) * 跑步的(零散时间，可以) * 羽毛球队（进去多被虐虐，可以） * Happy Coding!(没什么项目……，可以加吧) * （ 游泳千万别忘了） ","link":"https://https://github.com/Egg12138/post/guan-yu-she-tuan-hui-de-wen-ti/"},{"title":"关于中大的一些信息","content":"注意事项 在疫情防控的背景下,有些管理制度会发生变化 革命尚未成功，同志们仍需努力！ 来SYSU绝不可松懈 图书馆\\color{blue}{图书馆}图书馆 - 周日闭馆,开馆时不对外开放 -8：00 - 22：30 -图书借阅期限30days - [图书馆网站](http://library.sysu.edu.cn) 宿舍\\color{blue}{宿舍}宿舍 - 基础设施和保洁工作由物业负责 - 宿舍来访时间8-22点 奖惩\\color{blue}{奖惩}奖惩 - 国家奖学金、国家励志奖学金、中大励志奖学金不可兼得 - 一个人最多一个校级奖学金 - 同时获评按照单项最高金额发放 - ** 许多奖学金是要自主申请的！** - 情况： * **中大优秀学生奖学金** &gt; &lt;5%,&lt;10%,&lt;15%:4000,3000,2000 * **中大励志奖学金** &gt; 4000,3000 * **优秀毕业生** &gt; 本科生三年在所在单位专业排名前30%,毕设良好及以上或实习经历鉴定结果良好以上。 &gt; 在校期间未受过任何处分 * **推选名额** 不超过5% 医疗\\color{blue}{医疗}医疗 - 珠海区 210元/人 2020.7.1----2021.6.30 -代扣 | 年代/类型 | 系数 | 实 例 | | ---------- | --------: | :-------: | | 1910及以前 | 60 | 10元（原文献价格）×60（系数）+20元（文献加工费）＝620元 | | 1911-49 | 40 | 10元（原文献价格）×40（系数）+20元（文献加工费）＝420元 | | 1950-79 | 20 | 10元（原文献价格）×20（系数）+20元（文献加工费）＝220元 | | 1980-89 | 10 | 10元（原文献价格）×10（系数）+20元（文献加工费）＝120元 | | 1990-今 | 5 | 10元（原文献价格）× 5（系数）+20元（文献加工费）＝70元 | 系统 * 学工系统 * 开讲座、办社团活动，需要使用公共教室，来USC（[大学服务中心索引页](https://usc.sysu.edu.cn/taskcenter/workflow/index))平台办理“课室借用申请” * USC还可以申请勤工助学 ","link":"https://https://github.com/Egg12138/post/guan-yu-zhong-da-de-yi-xie-xin-xi/"},{"title":"复制了Markdown的最基本语法","content":"欢迎使用 Markdown在线编辑器 MdEditor Markdown是一种轻量级的「标记语言」 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md” MdEditor是一个在线编辑Markdown文档的编辑器 MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。 Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 MdEditor源于Pandao的JavaScript开源项目，开源地址Editor.md，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。 MdEditor的功能列表演示 标题H1 标题H2 标题H3 标题H4 标题H5 标题H5 字符效果和横线等 删除线 删除线（开启识别HTML标签时） 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 锚点与链接 Links 普通链接 普通链接带标题 直接链接：https://www.mdeditor.com [锚点链接][anchor-id] [anchor-id]: https://www.mdeditor.com/ mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com @pandao 多语言代码高亮 Codes 行内代码 Inline code 执行命令：npm install marked 缩进风格 即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 function test() { console.log(&quot;Hello world!&quot;); } HTML 代码 HTML codes &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Editor.md, Markdown, Editor&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{font-size:14px;color:#444;font-family: &quot;Microsoft Yahei&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;text-xxl&quot;&gt;Hello world!&lt;/h1&gt; &lt;p class=&quot;text-green&quot;&gt;Plain text&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 图片 Images 图片加链接 (Image + Link)： Follow your heart. 列表 Lists 无序列表（减号）Unordered Lists (-) 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*) 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+) 列表一 列表二 列表二-1 列表二-2 列表二-3 列表三 列表一 列表二 列表三 有序列表 Ordered Lists (-) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes © &amp; ¨ ™ ¡ £ &amp; &lt; &gt; ¥ € ® ± ¶ § ¦ ¯ « · X² Y³ ¾ ¼ × ÷ » 18ºC &quot; ' [========] Emoji表情 😃 Blockquotes ⭐️ GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x: 😃 @mentions, 😃 #refs, links, formatting, and tags :smiley: @mentions, :smiley: #refs, [links](), **formatting**, and tags supported :editormd-logo:; list syntax required (any unordered or ordered list supported) :editormd-logo-3x:; [ ] :smiley: this is a complete item :smiley:; []this is an incomplete item test link []this is an incomplete item [test link](#) :fa-star: @pandao; [ ]this is an incomplete item :fa-star: :fa-gear:; 😃 this is an incomplete item test link :smiley: this is an incomplete item [test link](#) :fa-star: :fa-gear:; 😃 this is :fa-star: :fa-gear: an incomplete item test link :smiley: this is :fa-star: :fa-gear: an incomplete item [test link](#); 反斜杠 Escape *literal asterisks* [========] 科学公式 TeX(KaTeX) E=mc2E=mc^2 E=mc2 行内的公式$$E=mc2$$行内的公式，行内的$$E=mc2$$公式。 x&gt;yx &gt; y x&gt;y \\(\\sqrt{3x-1}+(1+x)^2\\) sin⁡(α)θ=∑i=0n(xi+cos⁡(f))\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f)) sin(α)θ=i=0∑n​(xi+cos(f)) 多行公式： \\displaystyle \\left( \\sum\\_{k=1}^n a\\_k b\\_k \\right)^2 \\leq \\left( \\sum\\_{k=1}^n a\\_k^2 \\right) \\left( \\sum\\_{k=1}^n b\\_k^2 \\right) \\displaystyle \\frac{1}{ \\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{ \\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} { 1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } } f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi 分页符 Page break Print Test: Ctrl + P [========] 绘制流程图 Flowchart st=&gt;start: 用户登陆 op=&gt;operation: 登陆操作 cond=&gt;condition: 登陆成功 Yes or No? e=&gt;end: 进入后台 st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op [========] 绘制序列图 Sequence Diagram Andrew-&gt;China: Says Hello Note right of China: China thinks\\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! End ","link":"https://https://github.com/Egg12138/post/fu-zhi-liao-markdown-de-zui-ji-ben-yu-fa/"},{"title":"# Blog的再一次练笔——短期规划","content":"Blog的再一次练笔——短期规划 我想要明确一下短期内要干什么 现状:\\color{red}{现状:}现状: 太放纵了 许多习惯被抛弃 作息不够规律了，且睡点变迟 专注力下降，被频繁分散了。精力不集中，睡眠时间更长但是出现疲倦感 能力没有进步 英语阅读能力提高，只是因为英文文段看得多了一点 英语听力能力明显下降，暑假的听力拔高完全没有进行，** 还是只听得懂会的部分 ** 高数没有进修，大物相当危险 程序设计练习不够，一些题库也没做，别人的代码也没学 大物没有进展 饮食近期失控了！！！ 身体素质出现一定的弱化 短期措施:\\color{red}{短期措施:}短期措施: 应付分班考试 英语听力，利用9，10，11，12四天集中突击 强迫听写 短篇重复 口跟复述 英语阅读，碎片化即可。然后每天突击一下阅读 TownsendPress在宿舍内10，11，12进行 手机碎片化背单词（反正暑假没背完该背的……） Thomas Caculus阅读，正好复习一下 每天做些四六级考题 健康管理之饮食 (在宿舍之后确定一下这些方案是否可行) 早餐控制在室内进行，粗加工燕麦片+蛋白质 尽量不进入甜品店 礼品食物分给室友…… 我酒精过敏！ 健康管理之锻炼 力量训练优先 （补充上一点）利用时间进行长跑和羽毛球（只打一种球类运动） ","link":"https://https://github.com/Egg12138/post/blog-de-zai-yi-ci-lian-bi-duan-qi-gui-hua/"},{"title":"语言标准","content":" 同样的在html中也是center != centre哦 w3c的标准是谁制订的？ 谁先有能力制订标准的？ 你家有了标准还会好好地让别人自己建一套标准浪费资源而且偷走你的利益吗？ 标准就是那么一套，谁先谁订，人家的能力匹配得了，游戏规则就是这么简单😁 ","link":"https://https://github.com/Egg12138/post/comments-L-standard/"},{"title":"Testing Page","content":" 2019年，中国SCI论文发表数量超过50万篇，位列世界第二。 2000年，中国SCI期刊对中国学者论文的贡献是41%，到2018年下降到7.4%。 也就是说，100篇论文中只有7篇发表在中国期刊上，另93篇都发在国外期刊上。 此外，中国的SCI期刊数量也与中国SCI论文发展不匹配，中国期刊越来越滞后于中国论文的发展。 9000多种SCI期刊中，中国期刊只有241种。 转自公众号 中文期刊的现状是小、散、弱，同质化明显\\color{blue}{中文期刊的现状是小、散、弱，同质化明显}中文期刊的现状是小、散、弱，同质化明显 *小即规模小，一本期刊大约发200篇文章； *散即分布散，平均每个出版单位只有1.16种期刊； *弱即影响力弱，大多出版单位只有一种期刊，很难做大做强。 *同质化严重，缺乏学科分布、学术定位的考虑。大学学报中，以大学学院命名的有519种，约占中文期刊的12%，而大学学报都是综合性的，很难体现特色。 优秀论文走向国外的一些原因\\color{blue}{优秀论文走向国外的一些原因}优秀论文走向国外的一些原因 **我们的科技发达程度不足以支撑打造一本该领域的一流国际期刊。**从中文期刊本身的原因来说 学术共同体是分层次的，有些是引领性的，有些是跟随性的。引领性的不在中国，这种情况下国外期刊就是最好的选择。 **部分科研工作者要受到国际同行认可，需要国际舞台交流学术进展。**从科研人员的角度。 但是这一点并不于上一点矛盾，反而是加大了上一点的力度：“科研的舆论阵地”在国际上不以中国为主。 如果哪一天中国的需求走在世界前沿，又能够在国内找到技术方案，那这些技术来自哪里，哪里就会形成新的舆论阵地。 中文期刊发展的阻碍\\color{blue}{中文期刊发展的阻碍}中文期刊发展的阻碍 语言不通 语言是中文期刊国际化传播的劣势，大多数欧美一流学者是不懂中文的。而盲目办中文期刊的英文版是做无用功。 你的群体已经被限制在中国了，定位又不清晰，出了英文版欧美国家的科研人员会看吗？ 编辑“供不应求”,审稿速度迟缓，质量有限 中文期刊收版权费从而限制了版面。 一般投稿到中文期刊的论文不能超过8页，使论文残缺，不完整，虎头蛇尾。 展望\\color{blue}{展望}展望 94%的科研工作者认为需要中文期刊，同时对中文期刊的未来表示忧虑。所以必须搞好中文期刊，否则中国优秀论文终将离开本土 95%的科研工作者愿意为中文期刊做贡献，就是说中文期刊还是有潜力，可以发展好的。 **破除”唯国外搞影响因子期刊SCI“观念。**要让肯转到影响因子较低的一些国内期刊上发论文的科研人员尝到甜头。 应该说中文期刊在学术成果交流和人才培养中是十分重要的。 很多中文期刊的作者以研究生为主，也有期刊编辑或编委调侃中文期刊就是研究生的“作业本”，也就是说研究生最初的几篇文章都是通过审稿人的审稿、把关后在中文期刊发表的。 这个过程对于提升学生对研究的认识、提高学生的研究素养是很有帮助的。 所谓的研究能力培养，写文章和修改文章应该是最好的培养方式之一。 建议青年科学家更多、更早地参与到中文期刊的建设中， 如建立青年编委会或青年审稿人制度，让年轻有为的学者先参与进来，做期刊的审稿工作 ----------------------------任胜利 ","link":"https://https://github.com/Egg12138/post/SCI-myths/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://https://github.com/Egg12138/post/hello-gridea/"}]}